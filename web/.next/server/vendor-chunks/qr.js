"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/qr";
exports.ids = ["vendor-chunks/qr"];
exports.modules = {

/***/ "(ssr)/./node_modules/qr/index.js":
/*!**********************************!*\
  !*** ./node_modules/qr/index.js ***!
  \**********************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bitmap: () => (/* binding */ Bitmap),\n/* harmony export */   ECMode: () => (/* binding */ ECMode),\n/* harmony export */   Encoding: () => (/* binding */ Encoding),\n/* harmony export */   _tests: () => (/* binding */ _tests),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   encodeQR: () => (/* binding */ encodeQR),\n/* harmony export */   utf8ToBytes: () => (/* binding */ utf8ToBytes),\n/* harmony export */   utils: () => (/* binding */ utils)\n/* harmony export */ });\n/*!\nCopyright (c) 2023 Paul Miller (paulmillr.com)\nThe library paulmillr-qr is dual-licensed under the Apache 2.0 OR MIT license.\nYou can select a license of your choice.\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n/**\n * Methods for encoding (generating) QR code patterns.\n * Check out decode.ts for decoding (reading).\n * @module\n * @example\n```js\nimport encodeQR from 'qr';\nconst txt = 'Hello world';\nconst ascii = encodeQR(txt, 'ascii'); // Not all fonts are supported\nconst terminalFriendly = encodeQR(txt, 'term'); // 2x larger, all fonts are OK\nconst gifBytes = encodeQR(txt, 'gif'); // Uncompressed GIF\nconst svgElement = encodeQR(txt, 'svg'); // SVG vector image element\nconst array = encodeQR(txt, 'raw'); // 2d array for canvas or other libs\n// import decodeQR from 'qr/decode.js';\n```\n */\n// We do not use newline escape code directly in strings because it's not parser-friendly\nconst chCodes = { newline: 10, reset: 27 };\nfunction assertNumber(n) {\n    if (!Number.isSafeInteger(n))\n        throw new Error(`integer expected: ${n}`);\n}\nfunction validateVersion(ver) {\n    if (!Number.isSafeInteger(ver) || ver < 1 || ver > 40)\n        throw new Error(`Invalid version=${ver}. Expected number [1..40]`);\n}\nfunction bin(dec, pad) {\n    return dec.toString(2).padStart(pad, '0');\n}\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= 0 ? result : b + result;\n}\nfunction fillArr(length, val) {\n    return new Array(length).fill(val);\n}\nfunction popcnt(n) {\n    n = n - ((n >>> 1) & 0x55555555);\n    n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);\n    return (((n + (n >>> 4)) & 0x0f0f0f0f) * 0x01010101) >>> 24;\n}\n/**\n * Interleaves byte blocks.\n * @param blocks [[1, 2, 3], [4, 5, 6]]\n * @returns [1, 4, 2, 5, 3, 6]\n */\nfunction interleaveBytes(blocks) {\n    let maxLen = 0;\n    let totalLen = 0;\n    for (const block of blocks) {\n        maxLen = Math.max(maxLen, block.length);\n        totalLen += block.length;\n    }\n    const result = new Uint8Array(totalLen);\n    let idx = 0;\n    for (let i = 0; i < maxLen; i++) {\n        for (const block of blocks) {\n            if (i < block.length)\n                result[idx++] = block[i];\n        }\n    }\n    return result;\n}\n// Optimize for minimal score/penalty\nfunction best() {\n    let best;\n    let bestScore = Infinity;\n    return {\n        add(score, value) {\n            if (score >= bestScore)\n                return;\n            best = value;\n            bestScore = score;\n        },\n        get: () => best,\n        score: () => bestScore,\n    };\n}\n// Based on https://github.com/paulmillr/scure-base/blob/main/index.ts\nfunction alphabet(alphabet) {\n    return {\n        has: (char) => alphabet.includes(char),\n        decode: (input) => {\n            if (!Array.isArray(input) || (input.length && typeof input[0] !== 'string'))\n                throw new Error('alphabet.decode input should be array of strings');\n            return input.map((letter) => {\n                if (typeof letter !== 'string')\n                    throw new Error(`alphabet.decode: not string element=${letter}`);\n                const index = alphabet.indexOf(letter);\n                if (index === -1)\n                    throw new Error(`Unknown letter: \"${letter}\". Allowed: ${alphabet}`);\n                return index;\n            });\n        },\n        encode: (digits) => {\n            if (!Array.isArray(digits) || (digits.length && typeof digits[0] !== 'number'))\n                throw new Error('alphabet.encode input should be an array of numbers');\n            return digits.map((i) => {\n                assertNumber(i);\n                if (i < 0 || i >= alphabet.length)\n                    throw new Error(`Digit index outside alphabet: ${i} (alphabet: ${alphabet.length})`);\n                return alphabet[i];\n            });\n        },\n    };\n}\n// Transpose 32x32 bit matrix in-place\n// a[0..31] are 32 rows of 32 bits each; after transpose they become 32 columns.\nfunction transpose32(a) {\n    if (a.length !== 32)\n        throw new Error('expects 32 element matrix');\n    const masks = [0x55555555, 0x33333333, 0x0f0f0f0f, 0x00ff00ff, 0x0000ffff];\n    // Hello again, FFT\n    for (let stage = 0; stage < 5; stage++) {\n        const m = masks[stage] >>> 0;\n        const s = 1 << stage; // 1,2,4,8,16\n        const step = s << 1; // 2,4,8,16,32\n        for (let i = 0; i < 32; i += step) {\n            for (let k = 0; k < s; k++) {\n                const i0 = i + k;\n                const i1 = i0 + s;\n                const x = a[i0] >>> 0;\n                const y = a[i1] >>> 0;\n                const t = ((x >>> s) ^ y) & m;\n                a[i0] = (x ^ (t << s)) >>> 0;\n                a[i1] = (y ^ t) >>> 0;\n            }\n        }\n    }\n}\nconst bitMask = (x) => (1 << (x & 31)) >>> 0;\nconst rangeMask = (shift, len) => {\n    // len in [0..32], shift in [0..31]\n    if (len === 0)\n        return 0;\n    if (len === 32)\n        return 0xffffffff;\n    return (((1 << len) - 1) << shift) >>> 0;\n};\nclass Bitmap {\n    static size(size, limit) {\n        if (typeof size === 'number')\n            size = { height: size, width: size };\n        if (!Number.isSafeInteger(size.height) && size.height !== Infinity)\n            throw new Error(`Bitmap: invalid height=${size.height} (${typeof size.height})`);\n        if (!Number.isSafeInteger(size.width) && size.width !== Infinity)\n            throw new Error(`Bitmap: invalid width=${size.width} (${typeof size.width})`);\n        if (limit !== undefined) {\n            // Clamp length, so it won't overflow, also allows to use Infinity, so we draw until end\n            size = {\n                width: Math.min(size.width, limit.width),\n                height: Math.min(size.height, limit.height),\n            };\n        }\n        return size;\n    }\n    static fromString(s) {\n        // Remove linebreaks on start and end, so we draw in `` section\n        s = s.replace(/^\\n+/g, '').replace(/\\n+$/g, '');\n        const lines = s.split(String.fromCharCode(chCodes.newline));\n        const height = lines.length;\n        let width;\n        const rows = [];\n        for (const line of lines) {\n            const row = line.split('').map((i) => {\n                if (i === 'X')\n                    return true;\n                if (i === ' ')\n                    return false;\n                if (i === '?')\n                    return undefined;\n                throw new Error(`Bitmap.fromString: unknown symbol=${i}`);\n            });\n            if (width !== undefined && row.length !== width)\n                throw new Error(`Bitmap.fromString different row sizes: width=${width} cur=${row.length}`);\n            width = row.length;\n            rows.push(row);\n        }\n        if (width === undefined)\n            width = 0;\n        return new Bitmap({ height, width }, rows);\n    }\n    // Two bitsets:\n    // defined=0 -> undefined\n    // defined=1,value=0 -> false\n    // defined=1,value=1 -> true\n    defined;\n    value;\n    tailMask;\n    words;\n    fullWords;\n    height;\n    width;\n    constructor(size, data) {\n        const { height, width } = Bitmap.size(size);\n        this.height = height;\n        this.width = width;\n        this.tailMask = rangeMask(0, width & 31 || 32);\n        this.words = Math.ceil(width / 32) | 0;\n        this.fullWords = Math.floor(width / 32) | 0;\n        this.value = new Uint32Array(this.words * height);\n        this.defined = new Uint32Array(this.value.length);\n        if (data) {\n            // accept same semantics as old version\n            if (data.length !== height)\n                throw new Error(`Bitmap: data height mismatch: exp=${height} got=${data.length}`);\n            for (let y = 0; y < height; y++) {\n                const row = data[y];\n                if (!row || row.length !== width)\n                    throw new Error(`Bitmap: data width mismatch at y=${y}: exp=${width} got=${row?.length}`);\n                for (let x = 0; x < width; x++)\n                    this.set(x, y, row[x]);\n            }\n        }\n    }\n    point(p) {\n        return this.get(p.x, p.y);\n    }\n    isInside(p) {\n        return 0 <= p.x && p.x < this.width && 0 <= p.y && p.y < this.height;\n    }\n    size(offset) {\n        if (!offset)\n            return { height: this.height, width: this.width };\n        const { x, y } = this.xy(offset);\n        return { height: this.height - y, width: this.width - x };\n    }\n    xy(c) {\n        if (typeof c === 'number')\n            c = { x: c, y: c };\n        if (!Number.isSafeInteger(c.x))\n            throw new Error(`Bitmap: invalid x=${c.x}`);\n        if (!Number.isSafeInteger(c.y))\n            throw new Error(`Bitmap: invalid y=${c.y}`);\n        // Do modulo, so we can use negative positions\n        c.x = mod(c.x, this.width);\n        c.y = mod(c.y, this.height);\n        return c;\n    }\n    /**\n     * Return pixel bit index\n     */\n    wordIndex(x, y) {\n        return y * this.words + (x >>> 5);\n    }\n    bitIndex(x, y) {\n        return { word: this.wordIndex(x, y), bit: x & 31 };\n    }\n    isDefined(x, y) {\n        const wi = this.wordIndex(x, y);\n        const m = bitMask(x);\n        return (this.defined[wi] & m) !== 0;\n    }\n    get(x, y) {\n        const wi = this.wordIndex(x, y);\n        const m = bitMask(x);\n        return (this.value[wi] & m) !== 0;\n    }\n    maskWord(wi, mask, v) {\n        const { defined, value } = this;\n        defined[wi] |= mask;\n        value[wi] = (value[wi] & ~mask) | (-v & mask);\n    }\n    set(x, y, v) {\n        if (v === undefined)\n            return;\n        this.maskWord(this.wordIndex(x, y), bitMask(x), v);\n    }\n    // word-span fill for constant values (fast path)\n    fillRectConst(x0, y0, w, h, v) {\n        if (w <= 0 || h <= 0)\n            return;\n        if (v === undefined)\n            return;\n        const { value, defined, words } = this;\n        const startWord = x0 >>> 5;\n        const endWord = (x0 + w - 1) >>> 5;\n        const startBit = x0 & 31;\n        const endBit = (x0 + w - 1) & 31;\n        for (let ry = 0; ry < h; ry++) {\n            const rowBase = (y0 + ry) * words;\n            if (startWord === endWord) {\n                const mask = rangeMask(startBit, endBit - startBit + 1);\n                this.maskWord(rowBase + startWord, mask, v);\n                continue;\n            }\n            this.maskWord(rowBase + startWord, rangeMask(startBit, 32 - startBit), v);\n            for (let i = startWord + 1; i < endWord; i++) {\n                defined[rowBase + i] = 0xffffffff;\n                value[rowBase + i] = v ? 0xffffffff : 0;\n            }\n            this.maskWord(rowBase + endWord, rangeMask(0, endBit + 1), v);\n        }\n    }\n    rectWords(x, y, width, height, cb) {\n        for (let yPos = 0; yPos < height; yPos++) {\n            const Py = y + yPos;\n            for (let xPos = 0; xPos < width;) {\n                const bitX = x + xPos;\n                const { bit, word } = this.bitIndex(bitX, Py);\n                const bitsPerWord = Math.min(32 - bit, width - xPos);\n                cb(word, bitX, xPos, yPos, bitsPerWord);\n                xPos += bitsPerWord;\n            }\n        }\n    }\n    // Basically every operation can be represented as rect\n    rect(c, size, fn) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({ x, y }));\n        if (typeof fn !== 'function') {\n            this.fillRectConst(x, y, width, height, fn);\n            return this;\n        }\n        const { defined, value } = this;\n        this.rectWords(x, y, width, height, (wi, bitX, xPos, yPos, n) => {\n            let defWord = 0;\n            let valWord = value[wi];\n            for (let b = 0; b < n; b++) {\n                const mask = bitMask(bitX + b);\n                const res = fn({ x: xPos + b, y: yPos }, (valWord & mask) !== 0);\n                if (res === undefined)\n                    continue;\n                defWord |= mask;\n                valWord = (valWord & ~mask) | (-res & mask);\n            }\n            defined[wi] |= defWord;\n            value[wi] = valWord;\n        });\n        return this;\n    }\n    // returns rectangular part of bitmap\n    rectRead(c, size, fn) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({ x, y }));\n        const { value } = this;\n        this.rectWords(x, y, width, height, (wi, bitX, xPos, yPos, n) => {\n            const valWord = value[wi];\n            for (let b = 0; b < n; b++) {\n                const mask = bitMask(bitX + b);\n                fn({ x: xPos + b, y: yPos }, (valWord & mask) !== 0);\n            }\n        });\n        return this;\n    }\n    // Horizontal & vertical lines\n    hLine(c, len, value) {\n        return this.rect(c, { width: len, height: 1 }, value);\n    }\n    vLine(c, len, value) {\n        return this.rect(c, { width: 1, height: len }, value);\n    }\n    // add border\n    border(border = 2, value) {\n        const height = this.height + 2 * border;\n        const width = this.width + 2 * border;\n        const out = new Bitmap({ height, width });\n        // fill everything with border value, then embed original\n        out.rect(0, Infinity, value);\n        out.embed({ x: border, y: border }, this);\n        return out;\n    }\n    // Embed another bitmap on coordinates\n    embed(c, src) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(src.size(), this.size({ x, y }));\n        if (width <= 0 || height <= 0)\n            return this;\n        const { value, defined } = this;\n        const { words: srcStride, value: srcValue } = src;\n        for (let yPos = 0; yPos < height; yPos++) {\n            const srcRow = yPos * srcStride;\n            for (let xPos = 0; xPos < width;) {\n                const dstX = x + xPos;\n                const { word: dstWord, bit: dstBit } = this.bitIndex(dstX, y + yPos);\n                const { word: srcWord, bit: srcBit } = src.bitIndex(xPos, yPos);\n                const len = Math.min(32 - dstBit, width - xPos);\n                const w0 = srcValue[srcWord];\n                const w1 = srcBit && srcWord + 1 < srcRow + srcStride ? srcValue[srcWord + 1] : 0;\n                const sVal = srcBit ? ((w0 >>> srcBit) | (w1 << (32 - srcBit))) >>> 0 : w0;\n                const dstMask = rangeMask(dstBit, len);\n                const valBits = ((sVal & rangeMask(0, len)) << dstBit) >>> 0;\n                defined[dstWord] |= dstMask;\n                value[dstWord] = (value[dstWord] & ~dstMask) | valBits;\n                xPos += len;\n            }\n        }\n        return this;\n    }\n    // returns rectangular part of bitmap\n    rectSlice(c, size = this.size()) {\n        const { x, y } = this.xy(c);\n        const { height, width } = Bitmap.size(size, this.size({ x, y }));\n        const rect = new Bitmap({ height, width });\n        this.rectRead({ x, y }, { height, width }, (p, cur) => {\n            if (this.isDefined(x + p.x, y + p.y)) {\n                rect.set(p.x, p.y, cur);\n            }\n        });\n        return rect;\n    }\n    // Change shape, replace rows with columns (data[y][x] -> data[x][y])\n    transpose() {\n        const { height, width, value, defined, words } = this;\n        const dst = new Bitmap({ height: width, width: height });\n        const { words: dstStride, value: dstValue, defined: dstDefined, tailMask: dstTail } = dst;\n        const tmpV = new Uint32Array(32);\n        const tmpD = new Uint32Array(32);\n        // Process src in blocks: y in [by..by+31], x in 32-bit words\n        for (let by = 0; by < height; by += 32) {\n            for (let bx = 0; bx < words; bx++) {\n                const rows = Math.min(32, height - by);\n                for (let r = 0; r < rows; r++) {\n                    const wi = this.wordIndex(32 * bx, by + r);\n                    tmpV[r] = value[wi];\n                    tmpD[r] = defined[wi];\n                }\n                // zero-pad remainder\n                tmpV.fill(0, rows);\n                tmpD.fill(0, rows);\n                transpose32(tmpV);\n                transpose32(tmpD);\n                for (let i = 0; i < 32; i++) {\n                    const dstY = bx * 32 + i;\n                    if (dstY >= width)\n                        break;\n                    const dstPos = dst.wordIndex(by, dstY);\n                    const curMask = by >>> 5 === dstStride - 1 ? dstTail : 0xffffffff;\n                    dstValue[dstPos] = tmpV[i] & curMask;\n                    dstDefined[dstPos] = tmpD[i] & curMask;\n                }\n            }\n        }\n        return dst;\n    }\n    // black <-> white (inplace)\n    negate() {\n        const n = this.defined.length;\n        for (let i = 0; i < n; i++) {\n            this.value[i] = ~this.value[i];\n            this.defined[i] = 0xffffffff;\n        }\n        return this;\n    }\n    // Each pixel size is multiplied by factor\n    scale(factor) {\n        if (!Number.isSafeInteger(factor) || factor > 1024)\n            throw new Error(`invalid scale factor: ${factor}`);\n        const { height, width } = this;\n        const res = new Bitmap({ height: factor * height, width: factor * width });\n        return res.rect({ x: 0, y: 0 }, Infinity, ({ x, y }) => this.get((x / factor) | 0, (y / factor) | 0));\n    }\n    clone() {\n        const res = new Bitmap(this.size());\n        res.defined.set(this.defined);\n        res.value.set(this.value);\n        return res;\n    }\n    // Ensure that there is no undefined values left\n    assertDrawn() {\n        const { height, width, defined, tailMask, fullWords, words } = this;\n        if (!height || !width)\n            return;\n        for (let y = 0; y < height; y++) {\n            const rowBase = y * words;\n            for (let wi = 0; wi < fullWords; wi++) {\n                if (defined[rowBase + wi] !== 0xffffffff)\n                    throw new Error(`Invalid color type=undefined`);\n            }\n            if (words !== fullWords && (defined[rowBase + fullWords] & tailMask) !== tailMask)\n                throw new Error(`Invalid color type=undefined`);\n        }\n    }\n    countPatternInRow(y, patternLen, ...patterns) {\n        if (patternLen <= 0 || patternLen >= 32)\n            throw new Error('wrong patternLen');\n        const mask = (1 << patternLen) - 1;\n        const { width, value, words } = this;\n        let count = 0;\n        const rowBase = this.wordIndex(0, y);\n        for (let i = 0, window = 0; i < words; i++) {\n            const w = value[rowBase + i];\n            const bitEnd = i === words - 1 ? width & 31 || 32 : 32;\n            for (let b = 0; b < bitEnd; b++) {\n                window = ((window << 1) | ((w >>> b) & 1)) & mask;\n                if (i * 32 + b + 1 < patternLen)\n                    continue;\n                for (const p of patterns) {\n                    if (window !== p)\n                        continue;\n                    count++;\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n    getRuns(y, fn) {\n        const { width, value, words } = this;\n        if (width === 0)\n            return;\n        let runLen = 0;\n        let runValue;\n        const rowBase = this.wordIndex(0, y);\n        for (let i = 0; i < words; i++) {\n            const word = value[rowBase + i];\n            const bitEnd = i === words - 1 ? width & 31 || 32 : 32;\n            for (let b = 0; b < bitEnd; b++) {\n                const bit = (word & (1 << b)) !== 0;\n                if (bit === runValue) {\n                    runLen++;\n                    continue;\n                }\n                if (runValue !== undefined)\n                    fn(runLen, runValue);\n                runValue = bit;\n                runLen = 1;\n            }\n        }\n        if (runValue !== undefined)\n            fn(runLen, runValue);\n    }\n    popcnt() {\n        const { height, width, words, fullWords, tailMask } = this;\n        if (!height || !width)\n            return 0;\n        let count = 0;\n        for (let y = 0; y < height; y++) {\n            const rowBase = y * words;\n            for (let wi = 0; wi < fullWords; wi++)\n                count += popcnt(this.value[rowBase + wi]);\n            if (words !== fullWords)\n                count += popcnt(this.value[rowBase + fullWords] & tailMask);\n        }\n        return count;\n    }\n    countBoxes2x2(y) {\n        const { width, words } = this;\n        if (width < 2 || (y | 0) < 0 || y + 1 >= this.height)\n            return 0;\n        const base0 = this.wordIndex(0, y) | 0;\n        const base1 = this.wordIndex(0, y + 1) | 0;\n        // valid \"left-edge\" positions x in [0 .. W-2]\n        const tailBits = width & 31;\n        const validLast = tailBits === 0 ? 0x7fffffff : rangeMask(0, (width - 1) & 31);\n        let boxes = 0;\n        for (let wi = 0; wi < words; wi++) {\n            const a0 = this.value[base0 + wi];\n            const a1 = this.value[base1 + wi];\n            // Compare bit x with bit x+1 at same bit position.\n            const eqV = ~(a0 ^ a1) >>> 0; // row0[x] == row1[x]\n            const n0 = wi + 1 < words ? this.value[base0 + wi + 1] >>> 0 : 0;\n            const eqH0 = ~(a0 ^ (((a0 >>> 1) | ((n0 & 1) << 31)) >>> 0)) >>> 0; // row0[x] == row0[x+1]\n            const n1 = wi + 1 < words ? this.value[base1 + wi + 1] >>> 0 : 0;\n            const eqH1 = ~(a1 ^ (((a1 >>> 1) | ((n1 & 1) << 31)) >>> 0)) >>> 0; // row1[x] == row1[x+1]\n            let m = (eqV & eqH0 & eqH1) >>> 0;\n            if (wi === words - 1)\n                m &= validLast;\n            boxes += popcnt(m);\n        }\n        return boxes;\n    }\n    // Export\n    toString() {\n        const nl = String.fromCharCode(chCodes.newline);\n        let out = '';\n        for (let y = 0; y < this.height; y++) {\n            let line = '';\n            for (let x = 0; x < this.width; x++) {\n                const v = this.get(x, y);\n                line += !this.isDefined(x, y) ? '?' : v ? 'X' : ' ';\n            }\n            out += line + (y + 1 === this.height ? '' : nl);\n        }\n        return out;\n    }\n    toRaw() {\n        const out = Array.from({ length: this.height }, () => new Array(this.width));\n        for (let y = 0; y < this.height; y++) {\n            const row = out[y];\n            for (let x = 0; x < this.width; x++)\n                row[x] = this.get(x, y);\n        }\n        return out;\n    }\n    toASCII() {\n        const { height, width } = this;\n        let out = '';\n        // Terminal character height is x2 of character width, so we process two rows of bitmap\n        // to produce one row of ASCII\n        for (let y = 0; y < height; y += 2) {\n            for (let x = 0; x < width; x++) {\n                const first = this.get(x, y);\n                const second = y + 1 >= height ? true : this.get(x, y + 1); // if last row outside bitmap, make it black\n                if (!first && !second)\n                    out += '█'; // both rows white (empty)\n                else if (!first && second)\n                    out += '▀'; // top row white\n                else if (first && !second)\n                    out += '▄'; // down row white\n                else if (first && second)\n                    out += ' '; // both rows black\n            }\n            out += String.fromCharCode(chCodes.newline);\n        }\n        return out;\n    }\n    toTerm() {\n        const cc = String.fromCharCode(chCodes.reset);\n        const reset = cc + '[0m';\n        const whiteBG = cc + '[1;47m  ' + reset;\n        const darkBG = cc + `[40m  ` + reset;\n        const nl = String.fromCharCode(chCodes.newline);\n        let out = '';\n        for (let y = 0; y < this.height; y++) {\n            for (let x = 0; x < this.width; x++) {\n                const v = this.get(x, y); // undefined -> white\n                out += v ? darkBG : whiteBG;\n            }\n            out += nl;\n        }\n        return out;\n    }\n    toSVG(optimize = true) {\n        let out = `<svg viewBox=\"0 0 ${this.width} ${this.height}\" xmlns=\"http://www.w3.org/2000/svg\">`;\n        // Construct optimized SVG path data.\n        let pathData = '';\n        let prevPoint;\n        this.rectRead(0, Infinity, (point, val) => {\n            if (!val)\n                return;\n            const { x, y } = point;\n            if (!optimize) {\n                out += `<rect x=\"${x}\" y=\"${y}\" width=\"1\" height=\"1\" />`;\n                return;\n            }\n            // https://developer.mozilla.org/en-US/docs/Web/SVG/Reference/Attribute/d#path_commands\n            // Determine the shortest way to represent the initial cursor movement.\n            // M - Move cursor (without drawing) to absolute coordinate pair.\n            let m = `M${x} ${y}`;\n            // Only allow using the relative cursor move command if previous points\n            // were drawn.\n            if (prevPoint) {\n                // m - Move cursor (without drawing) to relative coordinate pair.\n                const relM = `m${x - prevPoint.x} ${y - prevPoint.y}`;\n                if (relM.length <= m.length)\n                    m = relM;\n            }\n            // Determine the shortest way to represent the cell's bottom line draw.\n            // H - Draw line from cursor position to absolute x coordinate.\n            // h - Draw line from cursor position to relative x coordinate.\n            const bH = x < 10 ? `H${x}` : 'h-1';\n            // v - Draw line from cursor position to relative y coordinate.\n            // Z - Close path (draws line from cursor position to M coordinate).\n            pathData += `${m}h1v1${bH}Z`;\n            prevPoint = point;\n        });\n        if (optimize)\n            out += `<path d=\"${pathData}\"/>`;\n        out += `</svg>`;\n        return out;\n    }\n    toGIF() {\n        // NOTE: Small, but inefficient implementation.\n        // Uses 1 byte per pixel.\n        const u16le = (i) => [i & 0xff, (i >>> 8) & 0xff];\n        const dims = [...u16le(this.width), ...u16le(this.height)];\n        const data = [];\n        this.rectRead(0, Infinity, (_, cur) => data.push(+(cur === true)));\n        const N = 126; // Block size\n        // prettier-ignore\n        const bytes = [\n            0x47, 0x49, 0x46, 0x38, 0x37, 0x61, ...dims, 0xf6, 0x00, 0x00, 0xff, 0xff, 0xff,\n            ...fillArr(3 * 127, 0x00), 0x2c, 0x00, 0x00, 0x00, 0x00, ...dims, 0x00, 0x07\n        ];\n        const fullChunks = Math.floor(data.length / N);\n        // Full blocks\n        for (let i = 0; i < fullChunks; i++)\n            bytes.push(N + 1, 0x80, ...data.slice(N * i, N * (i + 1)).map((i) => +i));\n        // Remaining bytes\n        bytes.push((data.length % N) + 1, 0x80, ...data.slice(fullChunks * N).map((i) => +i));\n        bytes.push(0x01, 0x81, 0x00, 0x3b);\n        return new Uint8Array(bytes);\n    }\n    toImage(isRGB = false) {\n        const { height, width } = this.size();\n        const data = new Uint8Array(height * width * (isRGB ? 3 : 4));\n        let i = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const value = this.get(x, y) ? 0 : 255; // undefined -> white\n                data[i++] = value;\n                data[i++] = value;\n                data[i++] = value;\n                if (!isRGB)\n                    data[i++] = 255; // alpha channel\n            }\n        }\n        return { height, width, data };\n    }\n}\n// End of utils\n// Runtime type-checking\n/** Error correction mode. low: 7%, medium: 15%, quartile: 25%, high: 30% */\nconst ECMode = ['low', 'medium', 'quartile', 'high'];\n/** QR Code encoding */\nconst Encoding = ['numeric', 'alphanumeric', 'byte', 'kanji', 'eci'];\n// Various constants & tables\n// prettier-ignore\nconst BYTES = [\n    // 1,  2,  3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,  16,  17,  18,  19,   20,\n    26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655, 733, 815, 901, 991, 1085,\n    //  21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,   33,   34,   35,   36,   37,   38,   39,   40\n    1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921, 2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,\n];\n// prettier-ignore\nconst WORDS_PER_BLOCK = {\n    // Version 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    medium: [10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],\n    quartile: [13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n    high: [17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],\n};\n// prettier-ignore\nconst ECC_BLOCKS = {\n    // Version   1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40\n    low: [1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],\n    medium: [1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],\n    quartile: [1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],\n    high: [1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81],\n};\nconst info = {\n    size: {\n        encode: (ver) => 21 + 4 * (ver - 1), // ver1 = 21, ver40=177 blocks\n        decode: (size) => (size - 17) / 4,\n    },\n    sizeType: (ver) => Math.floor((ver + 7) / 17),\n    // Based on https://codereview.stackexchange.com/questions/74925/algorithm-to-generate-this-alignment-pattern-locations-table-for-qr-codes\n    alignmentPatterns(ver) {\n        if (ver === 1)\n            return [];\n        const first = 6;\n        const last = info.size.encode(ver) - first - 1;\n        const distance = last - first;\n        const count = Math.ceil(distance / 28);\n        let interval = Math.floor(distance / count);\n        if (interval % 2)\n            interval += 1;\n        else if ((distance % count) * 2 >= count)\n            interval += 2;\n        const res = [first];\n        for (let m = 1; m < count; m++)\n            res.push(last - (count - m) * interval);\n        res.push(last);\n        return res;\n    },\n    ECCode: {\n        low: 0b01,\n        medium: 0b00,\n        quartile: 0b11,\n        high: 0b10,\n    },\n    formatMask: 0b101010000010010,\n    formatBits(ecc, maskIdx) {\n        const data = (info.ECCode[ecc] << 3) | maskIdx;\n        let d = data;\n        for (let i = 0; i < 10; i++)\n            d = (d << 1) ^ ((d >> 9) * 0b10100110111);\n        return ((data << 10) | d) ^ info.formatMask;\n    },\n    versionBits(ver) {\n        let d = ver;\n        for (let i = 0; i < 12; i++)\n            d = (d << 1) ^ ((d >> 11) * 0b1111100100101);\n        return (ver << 12) | d;\n    },\n    alphabet: {\n        numeric: alphabet('0123456789'),\n        alphanumerc: alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:'),\n    }, // as Record<EncodingType, ReturnType<typeof alphabet>>,\n    lengthBits(ver, type) {\n        const table = {\n            numeric: [10, 12, 14],\n            alphanumeric: [9, 11, 13],\n            byte: [8, 16, 16],\n            kanji: [8, 10, 12],\n            eci: [0, 0, 0],\n        };\n        return table[type][info.sizeType(ver)];\n    },\n    modeBits: {\n        numeric: '0001',\n        alphanumeric: '0010',\n        byte: '0100',\n        kanji: '1000',\n        eci: '0111',\n    },\n    capacity(ver, ecc) {\n        const bytes = BYTES[ver - 1];\n        const words = WORDS_PER_BLOCK[ecc][ver - 1];\n        const numBlocks = ECC_BLOCKS[ecc][ver - 1];\n        const blockLen = Math.floor(bytes / numBlocks) - words;\n        const shortBlocks = numBlocks - (bytes % numBlocks);\n        return {\n            words,\n            numBlocks,\n            shortBlocks,\n            blockLen,\n            capacity: (bytes - words * numBlocks) * 8,\n            total: (words + blockLen) * numBlocks + numBlocks - shortBlocks,\n        };\n    },\n};\nconst PATTERNS = [\n    (x, y) => (x + y) % 2 == 0,\n    (_x, y) => y % 2 == 0,\n    (x, _y) => x % 3 == 0,\n    (x, y) => (x + y) % 3 == 0,\n    (x, y) => (Math.floor(y / 2) + Math.floor(x / 3)) % 2 == 0,\n    (x, y) => ((x * y) % 2) + ((x * y) % 3) == 0,\n    (x, y) => (((x * y) % 2) + ((x * y) % 3)) % 2 == 0,\n    (x, y) => (((x + y) % 2) + ((x * y) % 3)) % 2 == 0,\n];\n// Galois field && reed-solomon encoding\nconst GF = {\n    tables: ((p_poly) => {\n        const exp = fillArr(256, 0);\n        const log = fillArr(256, 0);\n        for (let i = 0, x = 1; i < 256; i++) {\n            exp[i] = x;\n            log[x] = i;\n            x <<= 1;\n            if (x & 0x100)\n                x ^= p_poly;\n        }\n        return { exp, log };\n    })(0x11d),\n    exp: (x) => GF.tables.exp[x],\n    log(x) {\n        if (x === 0)\n            throw new Error(`GF.log: invalid arg=${x}`);\n        return GF.tables.log[x] % 255;\n    },\n    mul(x, y) {\n        if (x === 0 || y === 0)\n            return 0;\n        return GF.tables.exp[(GF.tables.log[x] + GF.tables.log[y]) % 255];\n    },\n    add: (x, y) => x ^ y,\n    pow: (x, e) => GF.tables.exp[(GF.tables.log[x] * e) % 255],\n    inv(x) {\n        if (x === 0)\n            throw new Error(`GF.inverse: invalid arg=${x}`);\n        return GF.tables.exp[255 - GF.tables.log[x]];\n    },\n    polynomial(poly) {\n        if (poly.length == 0)\n            throw new Error('GF.polymomial: invalid length');\n        if (poly[0] !== 0)\n            return poly;\n        // Strip leading zeros\n        let i = 0;\n        for (; i < poly.length - 1 && poly[i] == 0; i++)\n            ;\n        return poly.slice(i);\n    },\n    monomial(degree, coefficient) {\n        if (degree < 0)\n            throw new Error(`GF.monomial: invalid degree=${degree}`);\n        if (coefficient == 0)\n            return [0];\n        let coefficients = fillArr(degree + 1, 0);\n        coefficients[0] = coefficient;\n        return GF.polynomial(coefficients);\n    },\n    degree: (a) => a.length - 1,\n    coefficient: (a, degree) => a[GF.degree(a) - degree],\n    mulPoly(a, b) {\n        if (a[0] === 0 || b[0] === 0)\n            return [0];\n        const res = fillArr(a.length + b.length - 1, 0);\n        for (let i = 0; i < a.length; i++) {\n            for (let j = 0; j < b.length; j++) {\n                res[i + j] = GF.add(res[i + j], GF.mul(a[i], b[j]));\n            }\n        }\n        return GF.polynomial(res);\n    },\n    mulPolyScalar(a, scalar) {\n        if (scalar == 0)\n            return [0];\n        if (scalar == 1)\n            return a;\n        const res = fillArr(a.length, 0);\n        for (let i = 0; i < a.length; i++)\n            res[i] = GF.mul(a[i], scalar);\n        return GF.polynomial(res);\n    },\n    mulPolyMonomial(a, degree, coefficient) {\n        if (degree < 0)\n            throw new Error('GF.mulPolyMonomial: invalid degree');\n        if (coefficient == 0)\n            return [0];\n        const res = fillArr(a.length + degree, 0);\n        for (let i = 0; i < a.length; i++)\n            res[i] = GF.mul(a[i], coefficient);\n        return GF.polynomial(res);\n    },\n    addPoly(a, b) {\n        if (a[0] === 0)\n            return b;\n        if (b[0] === 0)\n            return a;\n        let smaller = a;\n        let larger = b;\n        if (smaller.length > larger.length)\n            [smaller, larger] = [larger, smaller];\n        let sumDiff = fillArr(larger.length, 0);\n        let lengthDiff = larger.length - smaller.length;\n        let s = larger.slice(0, lengthDiff);\n        for (let i = 0; i < s.length; i++)\n            sumDiff[i] = s[i];\n        for (let i = lengthDiff; i < larger.length; i++)\n            sumDiff[i] = GF.add(smaller[i - lengthDiff], larger[i]);\n        return GF.polynomial(sumDiff);\n    },\n    remainderPoly(data, divisor) {\n        const out = Array.from(data);\n        for (let i = 0; i < data.length - divisor.length + 1; i++) {\n            const elm = out[i];\n            if (elm === 0)\n                continue;\n            for (let j = 1; j < divisor.length; j++) {\n                if (divisor[j] !== 0)\n                    out[i + j] = GF.add(out[i + j], GF.mul(divisor[j], elm));\n            }\n        }\n        return out.slice(data.length - divisor.length + 1, out.length);\n    },\n    divisorPoly(degree) {\n        let g = [1];\n        for (let i = 0; i < degree; i++)\n            g = GF.mulPoly(g, [1, GF.pow(2, i)]);\n        return g;\n    },\n    evalPoly(poly, a) {\n        if (a == 0)\n            return GF.coefficient(poly, 0); // Just return the x^0 coefficient\n        let res = poly[0];\n        for (let i = 1; i < poly.length; i++)\n            res = GF.add(GF.mul(a, res), poly[i]);\n        return res;\n    },\n    // TODO: cleanup\n    euclidian(a, b, R) {\n        // Force degree(a) >= degree(b)\n        if (GF.degree(a) < GF.degree(b))\n            [a, b] = [b, a];\n        let rLast = a;\n        let r = b;\n        let tLast = [0];\n        let t = [1];\n        // while degree of Ri ≥ t/2\n        while (2 * GF.degree(r) >= R) {\n            let rLastLast = rLast;\n            let tLastLast = tLast;\n            rLast = r;\n            tLast = t;\n            if (rLast[0] === 0)\n                throw new Error('rLast[0] === 0');\n            r = rLastLast;\n            let q = [0];\n            const dltInverse = GF.inv(rLast[0]);\n            while (GF.degree(r) >= GF.degree(rLast) && r[0] !== 0) {\n                const degreeDiff = GF.degree(r) - GF.degree(rLast);\n                const scale = GF.mul(r[0], dltInverse);\n                q = GF.addPoly(q, GF.monomial(degreeDiff, scale));\n                r = GF.addPoly(r, GF.mulPolyMonomial(rLast, degreeDiff, scale));\n            }\n            q = GF.mulPoly(q, tLast);\n            t = GF.addPoly(q, tLastLast);\n            if (GF.degree(r) >= GF.degree(rLast))\n                throw new Error(`Division failed r: ${r}, rLast: ${rLast}`);\n        }\n        const sigmaTildeAtZero = GF.coefficient(t, 0);\n        if (sigmaTildeAtZero == 0)\n            throw new Error('sigmaTilde(0) was zero');\n        const inverse = GF.inv(sigmaTildeAtZero);\n        return [GF.mulPolyScalar(t, inverse), GF.mulPolyScalar(r, inverse)];\n    },\n};\nfunction RS(eccWords) {\n    return {\n        encode(from) {\n            const d = GF.divisorPoly(eccWords);\n            const pol = Array.from(from);\n            pol.push(...d.slice(0, -1).fill(0));\n            return Uint8Array.from(GF.remainderPoly(pol, d));\n        },\n        decode(to) {\n            const res = to.slice();\n            const poly = GF.polynomial(Array.from(to));\n            // Find errors\n            let syndrome = fillArr(eccWords, 0);\n            let hasError = false;\n            for (let i = 0; i < eccWords; i++) {\n                const evl = GF.evalPoly(poly, GF.exp(i));\n                syndrome[syndrome.length - 1 - i] = evl;\n                if (evl !== 0)\n                    hasError = true;\n            }\n            if (!hasError)\n                return res;\n            syndrome = GF.polynomial(syndrome);\n            const monomial = GF.monomial(eccWords, 1);\n            const [errorLocator, errorEvaluator] = GF.euclidian(monomial, syndrome, eccWords);\n            // Error locations\n            const locations = fillArr(GF.degree(errorLocator), 0);\n            let e = 0;\n            for (let i = 1; i < 256 && e < locations.length; i++) {\n                if (GF.evalPoly(errorLocator, i) === 0)\n                    locations[e++] = GF.inv(i);\n            }\n            if (e !== locations.length)\n                throw new Error('RS.decode: invalid errors number');\n            for (let i = 0; i < locations.length; i++) {\n                const pos = res.length - 1 - GF.log(locations[i]);\n                if (pos < 0)\n                    throw new Error('RS.decode: invalid error location');\n                const xiInverse = GF.inv(locations[i]);\n                let denominator = 1;\n                for (let j = 0; j < locations.length; j++) {\n                    if (i === j)\n                        continue;\n                    denominator = GF.mul(denominator, GF.add(1, GF.mul(locations[j], xiInverse)));\n                }\n                res[pos] = GF.add(res[pos], GF.mul(GF.evalPoly(errorEvaluator, xiInverse), GF.inv(denominator)));\n            }\n            return res;\n        },\n    };\n}\n// Interleaves blocks\nfunction interleave(ver, ecc) {\n    const { words, shortBlocks, numBlocks, blockLen, total } = info.capacity(ver, ecc);\n    const rs = RS(words);\n    return {\n        encode(bytes) {\n            // Add error correction to bytes\n            const blocks = [];\n            const eccBlocks = [];\n            for (let i = 0; i < numBlocks; i++) {\n                const isShort = i < shortBlocks;\n                const len = blockLen + (isShort ? 0 : 1);\n                blocks.push(bytes.subarray(0, len));\n                eccBlocks.push(rs.encode(bytes.subarray(0, len)));\n                bytes = bytes.subarray(len);\n            }\n            const resBlocks = interleaveBytes(blocks);\n            const resECC = interleaveBytes(eccBlocks);\n            const res = new Uint8Array(resBlocks.length + resECC.length);\n            res.set(resBlocks);\n            res.set(resECC, resBlocks.length);\n            return res;\n        },\n        decode(data) {\n            if (data.length !== total)\n                throw new Error(`interleave.decode: len(data)=${data.length}, total=${total}`);\n            const blocks = [];\n            for (let i = 0; i < numBlocks; i++) {\n                const isShort = i < shortBlocks;\n                blocks.push(new Uint8Array(words + blockLen + (isShort ? 0 : 1)));\n            }\n            // Short blocks\n            let pos = 0;\n            for (let i = 0; i < blockLen; i++) {\n                for (let j = 0; j < numBlocks; j++)\n                    blocks[j][i] = data[pos++];\n            }\n            // Long blocks\n            for (let j = shortBlocks; j < numBlocks; j++)\n                blocks[j][blockLen] = data[pos++];\n            // ECC\n            for (let i = blockLen; i < blockLen + words; i++) {\n                for (let j = 0; j < numBlocks; j++) {\n                    const isShort = j < shortBlocks;\n                    blocks[j][i + (isShort ? 0 : 1)] = data[pos++];\n                }\n            }\n            // Decode\n            // Error-correct and copy data blocks together into a stream of bytes\n            const res = [];\n            for (const block of blocks)\n                res.push(...Array.from(rs.decode(block)).slice(0, -words));\n            return Uint8Array.from(res);\n        },\n    };\n}\n// Draw\n// Generic template per version+ecc+mask. Can be cached, to speedup calculations.\nfunction drawTemplate(ver, ecc, maskIdx, test = false) {\n    const size = info.size.encode(ver);\n    let b = new Bitmap(size + 2);\n    // Finder patterns\n    // We draw full pattern and later slice, since before addition of borders finder is truncated by one pixel on sides\n    const finder = new Bitmap(3).rect(0, 3, true).border(1, false).border(1, true).border(1, false);\n    b = b\n        .embed(0, finder) // top left\n        .embed({ x: -finder.width, y: 0 }, finder) // top right\n        .embed({ x: 0, y: -finder.height }, finder); // bottom left\n    b = b.rectSlice(1, size);\n    // Alignment patterns\n    const align = new Bitmap(1).rect(0, 1, true).border(1, false).border(1, true);\n    const alignPos = info.alignmentPatterns(ver);\n    for (const y of alignPos) {\n        for (const x of alignPos) {\n            if (b.isDefined(x, y))\n                continue;\n            b.embed({ x: x - 2, y: y - 2 }, align); // center of pattern should be at position\n        }\n    }\n    // Timing patterns\n    b = b\n        .hLine({ x: 0, y: 6 }, Infinity, ({ x }) => (b.isDefined(x, 6) ? undefined : x % 2 == 0))\n        .vLine({ x: 6, y: 0 }, Infinity, ({ y }) => (b.isDefined(6, y) ? undefined : y % 2 == 0));\n    // Format information\n    {\n        const bits = info.formatBits(ecc, maskIdx);\n        const getBit = (i) => !test && ((bits >> i) & 1) == 1;\n        // vertical\n        for (let i = 0; i < 6; i++)\n            b.set(8, i, getBit(i)); // right of top-left finder\n        // TODO: re-write as lines, like:\n        // b.vLine({ x: 8, y: 0 }, 6, ({ x, y }) => getBit(y));\n        for (let i = 6; i < 8; i++)\n            b.set(8, i + 1, getBit(i)); // after timing pattern\n        for (let i = 8; i < 15; i++)\n            b.set(8, size - 15 + i, getBit(i)); // right of bottom-left finder\n        // horizontal\n        for (let i = 0; i < 8; i++)\n            b.set(size - i - 1, 8, getBit(i)); // under top-right finder\n        for (let i = 8; i < 9; i++)\n            b.set(15 - i - 1 + 1, 8, getBit(i)); // VVV, after timing\n        for (let i = 9; i < 15; i++)\n            b.set(15 - i - 1, 8, getBit(i)); // under top-left finder\n        b.set(8, size - 8, !test); // bottom-left finder, right\n    }\n    // Version information\n    if (ver >= 7) {\n        const bits = info.versionBits(ver);\n        for (let i = 0; i < 18; i += 1) {\n            const bit = !test && ((bits >> i) & 1) == 1;\n            const x = Math.floor(i / 3);\n            const y = (i % 3) + size - 8 - 3;\n            // two copies\n            b.set(y, x, bit);\n            b.set(x, y, bit);\n        }\n    }\n    return b;\n}\n// zigzag: bottom->top && top->bottom\nfunction zigzag(tpl, maskIdx, fn) {\n    const size = tpl.height;\n    const pattern = PATTERNS[maskIdx];\n    // zig-zag pattern\n    let dir = -1;\n    let y = size - 1;\n    // two columns at time\n    for (let xOffset = size - 1; xOffset > 0; xOffset -= 2) {\n        if (xOffset == 6)\n            xOffset = 5; // skip vertical timing pattern\n        for (;; y += dir) {\n            for (let j = 0; j < 2; j += 1) {\n                const x = xOffset - j;\n                if (tpl.isDefined(x, y))\n                    continue; // skip already written elements\n                fn(x, y, pattern(x, y));\n            }\n            if (y + dir < 0 || y + dir >= size)\n                break;\n        }\n        dir = -dir; // change direction\n    }\n}\n// NOTE: byte encoding is just representation, QR works with strings only. Most decoders will fail on raw byte array,\n// since they expect unicode or other text encoding inside bytes\nfunction detectType(str) {\n    let type = 'numeric';\n    for (let x of str) {\n        if (info.alphabet.numeric.has(x))\n            continue;\n        type = 'alphanumeric';\n        if (!info.alphabet.alphanumerc.has(x))\n            return 'byte';\n    }\n    return type;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\nfunction encode(ver, ecc, data, type, encoder = utf8ToBytes) {\n    let encoded = '';\n    let dataLen = data.length;\n    if (type === 'numeric') {\n        const t = info.alphabet.numeric.decode(data.split(''));\n        const n = t.length;\n        for (let i = 0; i < n - 2; i += 3)\n            encoded += bin(t[i] * 100 + t[i + 1] * 10 + t[i + 2], 10);\n        if (n % 3 === 1) {\n            encoded += bin(t[n - 1], 4);\n        }\n        else if (n % 3 === 2) {\n            encoded += bin(t[n - 2] * 10 + t[n - 1], 7);\n        }\n    }\n    else if (type === 'alphanumeric') {\n        const t = info.alphabet.alphanumerc.decode(data.split(''));\n        const n = t.length;\n        for (let i = 0; i < n - 1; i += 2)\n            encoded += bin(t[i] * 45 + t[i + 1], 11);\n        if (n % 2 == 1)\n            encoded += bin(t[n - 1], 6); // pad if odd number of chars\n    }\n    else if (type === 'byte') {\n        const utf8 = encoder(data);\n        dataLen = utf8.length;\n        encoded = Array.from(utf8)\n            .map((i) => bin(i, 8))\n            .join('');\n    }\n    else {\n        throw new Error('encode: unsupported type');\n    }\n    const { capacity } = info.capacity(ver, ecc);\n    const len = bin(dataLen, info.lengthBits(ver, type));\n    let bits = info.modeBits[type] + len + encoded;\n    if (bits.length > capacity)\n        throw new Error('Capacity overflow');\n    // Terminator\n    bits += '0'.repeat(Math.min(4, Math.max(0, capacity - bits.length)));\n    // Pad bits string untill full byte\n    if (bits.length % 8)\n        bits += '0'.repeat(8 - (bits.length % 8));\n    // Add padding until capacity is full\n    const padding = '1110110000010001';\n    for (let idx = 0; bits.length !== capacity; idx++)\n        bits += padding[idx % padding.length];\n    // Convert a bitstring to array of bytes\n    const bytes = Uint8Array.from(bits.match(/(.{8})/g).map((i) => Number(`0b${i}`)));\n    return interleave(ver, ecc).encode(bytes);\n}\n// DRAW\nfunction drawQR(ver, ecc, data, maskIdx, test = false) {\n    const b = drawTemplate(ver, ecc, maskIdx, test);\n    let i = 0;\n    const need = 8 * data.length;\n    zigzag(b, maskIdx, (x, y, mask) => {\n        let value = false;\n        if (i < need) {\n            value = ((data[i >>> 3] >> ((7 - i) & 7)) & 1) !== 0;\n            i++;\n        }\n        b.set(x, y, value !== mask); // !== as xor\n    });\n    if (i !== need)\n        throw new Error('QR: bytes left after draw');\n    return b;\n}\nconst mkPattern = (pattern) => {\n    const s = pattern.map((i) => (i ? '1' : '0')).join('');\n    return { len: s.length, n: Number(`0b${s}`) };\n};\n// 1:1:3:1:1 ratio (dark:light:dark:light:dark) pattern in row/column, preceded or followed by light area 4 modules wide\nconst finderPattern = [true, false, true, true, true, false, true]; // dark:light:dark:light:dark\nconst lightPattern = [false, false, false, false]; // light area 4 modules wide\nconst P1 = mkPattern([...finderPattern, ...lightPattern]);\nconst P2 = mkPattern([...lightPattern, ...finderPattern]);\nfunction penalty(bm) {\n    const { width, height } = bm;\n    const transposed = bm.transpose();\n    // Adjacent modules in row/column in same | No. of modules = (5 + i) color\n    let adjacent = 0;\n    for (let y = 0; y < height; y++) {\n        bm.getRuns(y, (len) => {\n            if (len >= 5)\n                adjacent += 3 + (len - 5);\n        });\n    }\n    for (let y = 0; y < width; y++) {\n        transposed.getRuns(y, (len) => {\n            if (len >= 5)\n                adjacent += 3 + (len - 5);\n        });\n    }\n    // Block of modules in same color (Block size = 2x2)\n    let box = 0;\n    for (let y = 0; y < height - 1; y++)\n        box += 3 * bm.countBoxes2x2(y);\n    let finder = 0;\n    for (let y = 0; y < height; y++)\n        finder += 40 * bm.countPatternInRow(y, P1.len, P1.n, P2.n);\n    for (let y = 0; y < width; y++)\n        finder += 40 * transposed.countPatternInRow(y, P1.len, P1.n, P2.n);\n    // Proportion of dark modules in entire symbol\n    // Add 10 points to a deviation of 5% increment or decrement in the proportion\n    // ratio of dark module from the referential 50%\n    let darkPixels = 0;\n    darkPixels = bm.popcnt();\n    //bm.rectRead(0, Infinity, (_c, val) => (darkPixels += val ? 1 : 0));\n    // for (let y = 0; y < height; y++) {\n    //   for (let x = 0; x < width; x++) if (bm.get(x, y)) darkPixels++;\n    // }\n    const darkPercent = (darkPixels / (height * width)) * 100;\n    const dark = 10 * Math.floor(Math.abs(darkPercent - 50) / 5);\n    return adjacent + box + finder + dark;\n}\n// Selects best mask according to penalty, if no mask is provided\nfunction drawQRBest(ver, ecc, data, maskIdx) {\n    if (maskIdx === undefined) {\n        const bestMask = best();\n        for (let mask = 0; mask < PATTERNS.length; mask++)\n            bestMask.add(penalty(drawQR(ver, ecc, data, mask, true)), mask);\n        maskIdx = bestMask.get();\n    }\n    if (maskIdx === undefined)\n        throw new Error('Cannot find mask'); // Should never happen\n    return drawQR(ver, ecc, data, maskIdx);\n}\nfunction validateECC(ec) {\n    if (!ECMode.includes(ec))\n        throw new Error(`Invalid error correction mode=${ec}. Expected: ${ECMode}`);\n}\nfunction validateEncoding(enc) {\n    if (!Encoding.includes(enc))\n        throw new Error(`Encoding: invalid mode=${enc}. Expected: ${Encoding}`);\n    if (enc === 'kanji' || enc === 'eci')\n        throw new Error(`Encoding: ${enc} is not supported (yet?).`);\n}\nfunction validateMask(mask) {\n    if (![0, 1, 2, 3, 4, 5, 6, 7].includes(mask) || !PATTERNS[mask])\n        throw new Error(`Invalid mask=${mask}. Expected number [0..7]`);\n}\nfunction encodeQR(text, output = 'raw', opts = {}) {\n    const ecc = opts.ecc !== undefined ? opts.ecc : 'medium';\n    validateECC(ecc);\n    const encoding = opts.encoding !== undefined ? opts.encoding : detectType(text);\n    validateEncoding(encoding);\n    if (opts.mask !== undefined)\n        validateMask(opts.mask);\n    let ver = opts.version;\n    let data, err = new Error('Unknown error');\n    if (ver !== undefined) {\n        validateVersion(ver);\n        data = encode(ver, ecc, text, encoding, opts.textEncoder);\n    }\n    else {\n        // If no version is provided, try to find smallest one which fits\n        // Currently just scans all version, can be significantly speedup if needed\n        for (let i = 1; i <= 40; i++) {\n            try {\n                data = encode(i, ecc, text, encoding, opts.textEncoder);\n                ver = i;\n                break;\n            }\n            catch (e) {\n                err = e;\n            }\n        }\n    }\n    if (!ver || !data)\n        throw err;\n    let res = drawQRBest(ver, ecc, data, opts.mask);\n    res.assertDrawn();\n    const border = opts.border === undefined ? 2 : opts.border;\n    if (!Number.isSafeInteger(border))\n        throw new Error(`invalid border type=${typeof border}`);\n    res = res.border(border, false); // Add border\n    if (opts.scale !== undefined)\n        res = res.scale(opts.scale); // Scale image\n    if (output === 'raw')\n        return res.toRaw();\n    else if (output === 'ascii')\n        return res.toASCII();\n    else if (output === 'svg')\n        return res.toSVG(opts.optimize);\n    else if (output === 'gif')\n        return res.toGIF();\n    else if (output === 'term')\n        return res.toTerm();\n    else\n        throw new Error(`Unknown output: ${output}`);\n}\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (encodeQR);\nconst utils = {\n    best,\n    bin,\n    popcnt,\n    drawTemplate,\n    fillArr,\n    info,\n    interleave,\n    validateVersion,\n    zigzag,\n};\n// Unsafe API utils, exported only for tests\nconst _tests = {\n    Bitmap,\n    info,\n    detectType,\n    encode,\n    drawQR,\n    penalty,\n    PATTERNS,\n};\n// Type tests\n// const o1 = qr('test', 'ascii');\n// const o2 = qr('test', 'raw');\n// const o3 = qr('test', 'gif');\n// const o4 = qr('test', 'svg');\n// const o5 = qr('test', 'term');\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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bkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsR0FBRyxjQUFjLE9BQU87QUFDakY7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELElBQUksY0FBYyxTQUFTO0FBQzdFO0FBQ0EscUNBQXFDLEtBQUs7QUFDMUM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLEtBQUs7QUFDN0M7QUFDTyxpREFBaUQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsY0FBYztBQUM3RCxxQ0FBcUM7QUFDckM7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0EsaUVBQWUsUUFBUSxFQUFDO0FBQ2pCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vb2FrLXByb3RvY29sLXdlYi8uL25vZGVfbW9kdWxlcy9xci9pbmRleC5qcz84ODE0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuQ29weXJpZ2h0IChjKSAyMDIzIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKVxuVGhlIGxpYnJhcnkgcGF1bG1pbGxyLXFyIGlzIGR1YWwtbGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSAyLjAgT1IgTUlUIGxpY2Vuc2UuXG5Zb3UgY2FuIHNlbGVjdCBhIGxpY2Vuc2Ugb2YgeW91ciBjaG9pY2UuXG5MaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xueW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG5TZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG5saW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG4vKipcbiAqIE1ldGhvZHMgZm9yIGVuY29kaW5nIChnZW5lcmF0aW5nKSBRUiBjb2RlIHBhdHRlcm5zLlxuICogQ2hlY2sgb3V0IGRlY29kZS50cyBmb3IgZGVjb2RpbmcgKHJlYWRpbmcpLlxuICogQG1vZHVsZVxuICogQGV4YW1wbGVcbmBgYGpzXG5pbXBvcnQgZW5jb2RlUVIgZnJvbSAncXInO1xuY29uc3QgdHh0ID0gJ0hlbGxvIHdvcmxkJztcbmNvbnN0IGFzY2lpID0gZW5jb2RlUVIodHh0LCAnYXNjaWknKTsgLy8gTm90IGFsbCBmb250cyBhcmUgc3VwcG9ydGVkXG5jb25zdCB0ZXJtaW5hbEZyaWVuZGx5ID0gZW5jb2RlUVIodHh0LCAndGVybScpOyAvLyAyeCBsYXJnZXIsIGFsbCBmb250cyBhcmUgT0tcbmNvbnN0IGdpZkJ5dGVzID0gZW5jb2RlUVIodHh0LCAnZ2lmJyk7IC8vIFVuY29tcHJlc3NlZCBHSUZcbmNvbnN0IHN2Z0VsZW1lbnQgPSBlbmNvZGVRUih0eHQsICdzdmcnKTsgLy8gU1ZHIHZlY3RvciBpbWFnZSBlbGVtZW50XG5jb25zdCBhcnJheSA9IGVuY29kZVFSKHR4dCwgJ3JhdycpOyAvLyAyZCBhcnJheSBmb3IgY2FudmFzIG9yIG90aGVyIGxpYnNcbi8vIGltcG9ydCBkZWNvZGVRUiBmcm9tICdxci9kZWNvZGUuanMnO1xuYGBgXG4gKi9cbi8vIFdlIGRvIG5vdCB1c2UgbmV3bGluZSBlc2NhcGUgY29kZSBkaXJlY3RseSBpbiBzdHJpbmdzIGJlY2F1c2UgaXQncyBub3QgcGFyc2VyLWZyaWVuZGx5XG5jb25zdCBjaENvZGVzID0geyBuZXdsaW5lOiAxMCwgcmVzZXQ6IDI3IH07XG5mdW5jdGlvbiBhc3NlcnROdW1iZXIobikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIobikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50ZWdlciBleHBlY3RlZDogJHtufWApO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVWZXJzaW9uKHZlcikge1xuICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmVyKSB8fCB2ZXIgPCAxIHx8IHZlciA+IDQwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmVyc2lvbj0ke3Zlcn0uIEV4cGVjdGVkIG51bWJlciBbMS4uNDBdYCk7XG59XG5mdW5jdGlvbiBiaW4oZGVjLCBwYWQpIHtcbiAgICByZXR1cm4gZGVjLnRvU3RyaW5nKDIpLnBhZFN0YXJ0KHBhZCwgJzAnKTtcbn1cbmZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYSAlIGI7XG4gICAgcmV0dXJuIHJlc3VsdCA+PSAwID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGZpbGxBcnIobGVuZ3RoLCB2YWwpIHtcbiAgICByZXR1cm4gbmV3IEFycmF5KGxlbmd0aCkuZmlsbCh2YWwpO1xufVxuZnVuY3Rpb24gcG9wY250KG4pIHtcbiAgICBuID0gbiAtICgobiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgICBuID0gKG4gJiAweDMzMzMzMzMzKSArICgobiA+Pj4gMikgJiAweDMzMzMzMzMzKTtcbiAgICByZXR1cm4gKCgobiArIChuID4+PiA0KSkgJiAweDBmMGYwZjBmKSAqIDB4MDEwMTAxMDEpID4+PiAyNDtcbn1cbi8qKlxuICogSW50ZXJsZWF2ZXMgYnl0ZSBibG9ja3MuXG4gKiBAcGFyYW0gYmxvY2tzIFtbMSwgMiwgM10sIFs0LCA1LCA2XV1cbiAqIEByZXR1cm5zIFsxLCA0LCAyLCA1LCAzLCA2XVxuICovXG5mdW5jdGlvbiBpbnRlcmxlYXZlQnl0ZXMoYmxvY2tzKSB7XG4gICAgbGV0IG1heExlbiA9IDA7XG4gICAgbGV0IHRvdGFsTGVuID0gMDtcbiAgICBmb3IgKGNvbnN0IGJsb2NrIG9mIGJsb2Nrcykge1xuICAgICAgICBtYXhMZW4gPSBNYXRoLm1heChtYXhMZW4sIGJsb2NrLmxlbmd0aCk7XG4gICAgICAgIHRvdGFsTGVuICs9IGJsb2NrLmxlbmd0aDtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW4pO1xuICAgIGxldCBpZHggPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuOyBpKyspIHtcbiAgICAgICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpIHtcbiAgICAgICAgICAgIGlmIChpIDwgYmxvY2subGVuZ3RoKVxuICAgICAgICAgICAgICAgIHJlc3VsdFtpZHgrK10gPSBibG9ja1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gT3B0aW1pemUgZm9yIG1pbmltYWwgc2NvcmUvcGVuYWx0eVxuZnVuY3Rpb24gYmVzdCgpIHtcbiAgICBsZXQgYmVzdDtcbiAgICBsZXQgYmVzdFNjb3JlID0gSW5maW5pdHk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkKHNjb3JlLCB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHNjb3JlID49IGJlc3RTY29yZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBiZXN0ID0gdmFsdWU7XG4gICAgICAgICAgICBiZXN0U2NvcmUgPSBzY29yZTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0OiAoKSA9PiBiZXN0LFxuICAgICAgICBzY29yZTogKCkgPT4gYmVzdFNjb3JlLFxuICAgIH07XG59XG4vLyBCYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vcGF1bG1pbGxyL3NjdXJlLWJhc2UvYmxvYi9tYWluL2luZGV4LnRzXG5mdW5jdGlvbiBhbHBoYWJldChhbHBoYWJldCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGhhczogKGNoYXIpID0+IGFscGhhYmV0LmluY2x1ZGVzKGNoYXIpLFxuICAgICAgICBkZWNvZGU6IChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSB8fCAoaW5wdXQubGVuZ3RoICYmIHR5cGVvZiBpbnB1dFswXSAhPT0gJ3N0cmluZycpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYWxwaGFiZXQuZGVjb2RlIGlucHV0IHNob3VsZCBiZSBhcnJheSBvZiBzdHJpbmdzJyk7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQubWFwKChsZXR0ZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGxldHRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgYWxwaGFiZXQuZGVjb2RlOiBub3Qgc3RyaW5nIGVsZW1lbnQ9JHtsZXR0ZXJ9YCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBhbHBoYWJldC5pbmRleE9mKGxldHRlcik7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGxldHRlcjogXCIke2xldHRlcn1cIi4gQWxsb3dlZDogJHthbHBoYWJldH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZW5jb2RlOiAoZGlnaXRzKSA9PiB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlnaXRzKSB8fCAoZGlnaXRzLmxlbmd0aCAmJiB0eXBlb2YgZGlnaXRzWzBdICE9PSAnbnVtYmVyJykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhbHBoYWJldC5lbmNvZGUgaW5wdXQgc2hvdWxkIGJlIGFuIGFycmF5IG9mIG51bWJlcnMnKTtcbiAgICAgICAgICAgIHJldHVybiBkaWdpdHMubWFwKChpKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TnVtYmVyKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpIDwgMCB8fCBpID49IGFscGhhYmV0Lmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEaWdpdCBpbmRleCBvdXRzaWRlIGFscGhhYmV0OiAke2l9IChhbHBoYWJldDogJHthbHBoYWJldC5sZW5ndGh9KWApO1xuICAgICAgICAgICAgICAgIHJldHVybiBhbHBoYWJldFtpXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBUcmFuc3Bvc2UgMzJ4MzIgYml0IG1hdHJpeCBpbi1wbGFjZVxuLy8gYVswLi4zMV0gYXJlIDMyIHJvd3Mgb2YgMzIgYml0cyBlYWNoOyBhZnRlciB0cmFuc3Bvc2UgdGhleSBiZWNvbWUgMzIgY29sdW1ucy5cbmZ1bmN0aW9uIHRyYW5zcG9zZTMyKGEpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IDMyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4cGVjdHMgMzIgZWxlbWVudCBtYXRyaXgnKTtcbiAgICBjb25zdCBtYXNrcyA9IFsweDU1NTU1NTU1LCAweDMzMzMzMzMzLCAweDBmMGYwZjBmLCAweDAwZmYwMGZmLCAweDAwMDBmZmZmXTtcbiAgICAvLyBIZWxsbyBhZ2FpbiwgRkZUXG4gICAgZm9yIChsZXQgc3RhZ2UgPSAwOyBzdGFnZSA8IDU7IHN0YWdlKyspIHtcbiAgICAgICAgY29uc3QgbSA9IG1hc2tzW3N0YWdlXSA+Pj4gMDtcbiAgICAgICAgY29uc3QgcyA9IDEgPDwgc3RhZ2U7IC8vIDEsMiw0LDgsMTZcbiAgICAgICAgY29uc3Qgc3RlcCA9IHMgPDwgMTsgLy8gMiw0LDgsMTYsMzJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSArPSBzdGVwKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHM7IGsrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGkwID0gaSArIGs7XG4gICAgICAgICAgICAgICAgY29uc3QgaTEgPSBpMCArIHM7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IGFbaTBdID4+PiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBhW2kxXSA+Pj4gMDtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gKCh4ID4+PiBzKSBeIHkpICYgbTtcbiAgICAgICAgICAgICAgICBhW2kwXSA9ICh4IF4gKHQgPDwgcykpID4+PiAwO1xuICAgICAgICAgICAgICAgIGFbaTFdID0gKHkgXiB0KSA+Pj4gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGJpdE1hc2sgPSAoeCkgPT4gKDEgPDwgKHggJiAzMSkpID4+PiAwO1xuY29uc3QgcmFuZ2VNYXNrID0gKHNoaWZ0LCBsZW4pID0+IHtcbiAgICAvLyBsZW4gaW4gWzAuLjMyXSwgc2hpZnQgaW4gWzAuLjMxXVxuICAgIGlmIChsZW4gPT09IDApXG4gICAgICAgIHJldHVybiAwO1xuICAgIGlmIChsZW4gPT09IDMyKVxuICAgICAgICByZXR1cm4gMHhmZmZmZmZmZjtcbiAgICByZXR1cm4gKCgoMSA8PCBsZW4pIC0gMSkgPDwgc2hpZnQpID4+PiAwO1xufTtcbmV4cG9ydCBjbGFzcyBCaXRtYXAge1xuICAgIHN0YXRpYyBzaXplKHNpemUsIGxpbWl0KSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBzaXplID0geyBoZWlnaHQ6IHNpemUsIHdpZHRoOiBzaXplIH07XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoc2l6ZS5oZWlnaHQpICYmIHNpemUuaGVpZ2h0ICE9PSBJbmZpbml0eSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwOiBpbnZhbGlkIGhlaWdodD0ke3NpemUuaGVpZ2h0fSAoJHt0eXBlb2Ygc2l6ZS5oZWlnaHR9KWApO1xuICAgICAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKHNpemUud2lkdGgpICYmIHNpemUud2lkdGggIT09IEluZmluaXR5KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGludmFsaWQgd2lkdGg9JHtzaXplLndpZHRofSAoJHt0eXBlb2Ygc2l6ZS53aWR0aH0pYCk7XG4gICAgICAgIGlmIChsaW1pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBDbGFtcCBsZW5ndGgsIHNvIGl0IHdvbid0IG92ZXJmbG93LCBhbHNvIGFsbG93cyB0byB1c2UgSW5maW5pdHksIHNvIHdlIGRyYXcgdW50aWwgZW5kXG4gICAgICAgICAgICBzaXplID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLm1pbihzaXplLndpZHRoLCBsaW1pdC53aWR0aCksXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBNYXRoLm1pbihzaXplLmhlaWdodCwgbGltaXQuaGVpZ2h0KSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHMpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGxpbmVicmVha3Mgb24gc3RhcnQgYW5kIGVuZCwgc28gd2UgZHJhdyBpbiBgYCBzZWN0aW9uXG4gICAgICAgIHMgPSBzLnJlcGxhY2UoL15cXG4rL2csICcnKS5yZXBsYWNlKC9cXG4rJC9nLCAnJyk7XG4gICAgICAgIGNvbnN0IGxpbmVzID0gcy5zcGxpdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoQ29kZXMubmV3bGluZSkpO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIGxldCB3aWR0aDtcbiAgICAgICAgY29uc3Qgcm93cyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJvdyA9IGxpbmUuc3BsaXQoJycpLm1hcCgoaSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnWCcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAnICcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gJz8nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwLmZyb21TdHJpbmc6IHVua25vd24gc3ltYm9sPSR7aX1gKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdpZHRoICE9PSB1bmRlZmluZWQgJiYgcm93Lmxlbmd0aCAhPT0gd2lkdGgpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXAuZnJvbVN0cmluZyBkaWZmZXJlbnQgcm93IHNpemVzOiB3aWR0aD0ke3dpZHRofSBjdXI9JHtyb3cubGVuZ3RofWApO1xuICAgICAgICAgICAgd2lkdGggPSByb3cubGVuZ3RoO1xuICAgICAgICAgICAgcm93cy5wdXNoKHJvdyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICB3aWR0aCA9IDA7XG4gICAgICAgIHJldHVybiBuZXcgQml0bWFwKHsgaGVpZ2h0LCB3aWR0aCB9LCByb3dzKTtcbiAgICB9XG4gICAgLy8gVHdvIGJpdHNldHM6XG4gICAgLy8gZGVmaW5lZD0wIC0+IHVuZGVmaW5lZFxuICAgIC8vIGRlZmluZWQ9MSx2YWx1ZT0wIC0+IGZhbHNlXG4gICAgLy8gZGVmaW5lZD0xLHZhbHVlPTEgLT4gdHJ1ZVxuICAgIGRlZmluZWQ7XG4gICAgdmFsdWU7XG4gICAgdGFpbE1hc2s7XG4gICAgd29yZHM7XG4gICAgZnVsbFdvcmRzO1xuICAgIGhlaWdodDtcbiAgICB3aWR0aDtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gQml0bWFwLnNpemUoc2l6ZSk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMudGFpbE1hc2sgPSByYW5nZU1hc2soMCwgd2lkdGggJiAzMSB8fCAzMik7XG4gICAgICAgIHRoaXMud29yZHMgPSBNYXRoLmNlaWwod2lkdGggLyAzMikgfCAwO1xuICAgICAgICB0aGlzLmZ1bGxXb3JkcyA9IE1hdGguZmxvb3Iod2lkdGggLyAzMikgfCAwO1xuICAgICAgICB0aGlzLnZhbHVlID0gbmV3IFVpbnQzMkFycmF5KHRoaXMud29yZHMgKiBoZWlnaHQpO1xuICAgICAgICB0aGlzLmRlZmluZWQgPSBuZXcgVWludDMyQXJyYXkodGhpcy52YWx1ZS5sZW5ndGgpO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gYWNjZXB0IHNhbWUgc2VtYW50aWNzIGFzIG9sZCB2ZXJzaW9uXG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IGhlaWdodClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJpdG1hcDogZGF0YSBoZWlnaHQgbWlzbWF0Y2g6IGV4cD0ke2hlaWdodH0gZ290PSR7ZGF0YS5sZW5ndGh9YCk7XG4gICAgICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm93ID0gZGF0YVt5XTtcbiAgICAgICAgICAgICAgICBpZiAoIXJvdyB8fCByb3cubGVuZ3RoICE9PSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBCaXRtYXA6IGRhdGEgd2lkdGggbWlzbWF0Y2ggYXQgeT0ke3l9OiBleHA9JHt3aWR0aH0gZ290PSR7cm93Py5sZW5ndGh9YCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldCh4LCB5LCByb3dbeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBvaW50KHApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHAueCwgcC55KTtcbiAgICB9XG4gICAgaXNJbnNpZGUocCkge1xuICAgICAgICByZXR1cm4gMCA8PSBwLnggJiYgcC54IDwgdGhpcy53aWR0aCAmJiAwIDw9IHAueSAmJiBwLnkgPCB0aGlzLmhlaWdodDtcbiAgICB9XG4gICAgc2l6ZShvZmZzZXQpIHtcbiAgICAgICAgaWYgKCFvZmZzZXQpXG4gICAgICAgICAgICByZXR1cm4geyBoZWlnaHQ6IHRoaXMuaGVpZ2h0LCB3aWR0aDogdGhpcy53aWR0aCB9O1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMueHkob2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0OiB0aGlzLmhlaWdodCAtIHksIHdpZHRoOiB0aGlzLndpZHRoIC0geCB9O1xuICAgIH1cbiAgICB4eShjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYyA9PT0gJ251bWJlcicpXG4gICAgICAgICAgICBjID0geyB4OiBjLCB5OiBjIH07XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYy54KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwOiBpbnZhbGlkIHg9JHtjLnh9YCk7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoYy55KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQml0bWFwOiBpbnZhbGlkIHk9JHtjLnl9YCk7XG4gICAgICAgIC8vIERvIG1vZHVsbywgc28gd2UgY2FuIHVzZSBuZWdhdGl2ZSBwb3NpdGlvbnNcbiAgICAgICAgYy54ID0gbW9kKGMueCwgdGhpcy53aWR0aCk7XG4gICAgICAgIGMueSA9IG1vZChjLnksIHRoaXMuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBwaXhlbCBiaXQgaW5kZXhcbiAgICAgKi9cbiAgICB3b3JkSW5kZXgoeCwgeSkge1xuICAgICAgICByZXR1cm4geSAqIHRoaXMud29yZHMgKyAoeCA+Pj4gNSk7XG4gICAgfVxuICAgIGJpdEluZGV4KHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHsgd29yZDogdGhpcy53b3JkSW5kZXgoeCwgeSksIGJpdDogeCAmIDMxIH07XG4gICAgfVxuICAgIGlzRGVmaW5lZCh4LCB5KSB7XG4gICAgICAgIGNvbnN0IHdpID0gdGhpcy53b3JkSW5kZXgoeCwgeSk7XG4gICAgICAgIGNvbnN0IG0gPSBiaXRNYXNrKHgpO1xuICAgICAgICByZXR1cm4gKHRoaXMuZGVmaW5lZFt3aV0gJiBtKSAhPT0gMDtcbiAgICB9XG4gICAgZ2V0KHgsIHkpIHtcbiAgICAgICAgY29uc3Qgd2kgPSB0aGlzLndvcmRJbmRleCh4LCB5KTtcbiAgICAgICAgY29uc3QgbSA9IGJpdE1hc2soeCk7XG4gICAgICAgIHJldHVybiAodGhpcy52YWx1ZVt3aV0gJiBtKSAhPT0gMDtcbiAgICB9XG4gICAgbWFza1dvcmQod2ksIG1hc2ssIHYpIHtcbiAgICAgICAgY29uc3QgeyBkZWZpbmVkLCB2YWx1ZSB9ID0gdGhpcztcbiAgICAgICAgZGVmaW5lZFt3aV0gfD0gbWFzaztcbiAgICAgICAgdmFsdWVbd2ldID0gKHZhbHVlW3dpXSAmIH5tYXNrKSB8ICgtdiAmIG1hc2spO1xuICAgIH1cbiAgICBzZXQoeCwgeSwgdikge1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm1hc2tXb3JkKHRoaXMud29yZEluZGV4KHgsIHkpLCBiaXRNYXNrKHgpLCB2KTtcbiAgICB9XG4gICAgLy8gd29yZC1zcGFuIGZpbGwgZm9yIGNvbnN0YW50IHZhbHVlcyAoZmFzdCBwYXRoKVxuICAgIGZpbGxSZWN0Q29uc3QoeDAsIHkwLCB3LCBoLCB2KSB7XG4gICAgICAgIGlmICh3IDw9IDAgfHwgaCA8PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkZWZpbmVkLCB3b3JkcyB9ID0gdGhpcztcbiAgICAgICAgY29uc3Qgc3RhcnRXb3JkID0geDAgPj4+IDU7XG4gICAgICAgIGNvbnN0IGVuZFdvcmQgPSAoeDAgKyB3IC0gMSkgPj4+IDU7XG4gICAgICAgIGNvbnN0IHN0YXJ0Qml0ID0geDAgJiAzMTtcbiAgICAgICAgY29uc3QgZW5kQml0ID0gKHgwICsgdyAtIDEpICYgMzE7XG4gICAgICAgIGZvciAobGV0IHJ5ID0gMDsgcnkgPCBoOyByeSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3dCYXNlID0gKHkwICsgcnkpICogd29yZHM7XG4gICAgICAgICAgICBpZiAoc3RhcnRXb3JkID09PSBlbmRXb3JkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWFzayA9IHJhbmdlTWFzayhzdGFydEJpdCwgZW5kQml0IC0gc3RhcnRCaXQgKyAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1hc2tXb3JkKHJvd0Jhc2UgKyBzdGFydFdvcmQsIG1hc2ssIHYpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5tYXNrV29yZChyb3dCYXNlICsgc3RhcnRXb3JkLCByYW5nZU1hc2soc3RhcnRCaXQsIDMyIC0gc3RhcnRCaXQpLCB2KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydFdvcmQgKyAxOyBpIDwgZW5kV29yZDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lZFtyb3dCYXNlICsgaV0gPSAweGZmZmZmZmZmO1xuICAgICAgICAgICAgICAgIHZhbHVlW3Jvd0Jhc2UgKyBpXSA9IHYgPyAweGZmZmZmZmZmIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWFza1dvcmQocm93QmFzZSArIGVuZFdvcmQsIHJhbmdlTWFzaygwLCBlbmRCaXQgKyAxKSwgdik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVjdFdvcmRzKHgsIHksIHdpZHRoLCBoZWlnaHQsIGNiKSB7XG4gICAgICAgIGZvciAobGV0IHlQb3MgPSAwOyB5UG9zIDwgaGVpZ2h0OyB5UG9zKyspIHtcbiAgICAgICAgICAgIGNvbnN0IFB5ID0geSArIHlQb3M7XG4gICAgICAgICAgICBmb3IgKGxldCB4UG9zID0gMDsgeFBvcyA8IHdpZHRoOykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJpdFggPSB4ICsgeFBvcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGJpdCwgd29yZCB9ID0gdGhpcy5iaXRJbmRleChiaXRYLCBQeSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0c1BlcldvcmQgPSBNYXRoLm1pbigzMiAtIGJpdCwgd2lkdGggLSB4UG9zKTtcbiAgICAgICAgICAgICAgICBjYih3b3JkLCBiaXRYLCB4UG9zLCB5UG9zLCBiaXRzUGVyV29yZCk7XG4gICAgICAgICAgICAgICAgeFBvcyArPSBiaXRzUGVyV29yZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCYXNpY2FsbHkgZXZlcnkgb3BlcmF0aW9uIGNhbiBiZSByZXByZXNlbnRlZCBhcyByZWN0XG4gICAgcmVjdChjLCBzaXplLCBmbikge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMueHkoYyk7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gQml0bWFwLnNpemUoc2l6ZSwgdGhpcy5zaXplKHsgeCwgeSB9KSk7XG4gICAgICAgIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlY3RDb25zdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBmbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGRlZmluZWQsIHZhbHVlIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLnJlY3RXb3Jkcyh4LCB5LCB3aWR0aCwgaGVpZ2h0LCAod2ksIGJpdFgsIHhQb3MsIHlQb3MsIG4pID0+IHtcbiAgICAgICAgICAgIGxldCBkZWZXb3JkID0gMDtcbiAgICAgICAgICAgIGxldCB2YWxXb3JkID0gdmFsdWVbd2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBuOyBiKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gYml0TWFzayhiaXRYICsgYik7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gZm4oeyB4OiB4UG9zICsgYiwgeTogeVBvcyB9LCAodmFsV29yZCAmIG1hc2spICE9PSAwKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGRlZldvcmQgfD0gbWFzaztcbiAgICAgICAgICAgICAgICB2YWxXb3JkID0gKHZhbFdvcmQgJiB+bWFzaykgfCAoLXJlcyAmIG1hc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lZFt3aV0gfD0gZGVmV29yZDtcbiAgICAgICAgICAgIHZhbHVlW3dpXSA9IHZhbFdvcmQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gcmV0dXJucyByZWN0YW5ndWxhciBwYXJ0IG9mIGJpdG1hcFxuICAgIHJlY3RSZWFkKGMsIHNpemUsIGZuKSB7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gdGhpcy54eShjKTtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSBCaXRtYXAuc2l6ZShzaXplLCB0aGlzLnNpemUoeyB4LCB5IH0pKTtcbiAgICAgICAgY29uc3QgeyB2YWx1ZSB9ID0gdGhpcztcbiAgICAgICAgdGhpcy5yZWN0V29yZHMoeCwgeSwgd2lkdGgsIGhlaWdodCwgKHdpLCBiaXRYLCB4UG9zLCB5UG9zLCBuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWxXb3JkID0gdmFsdWVbd2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBuOyBiKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtYXNrID0gYml0TWFzayhiaXRYICsgYik7XG4gICAgICAgICAgICAgICAgZm4oeyB4OiB4UG9zICsgYiwgeTogeVBvcyB9LCAodmFsV29yZCAmIG1hc2spICE9PSAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyBIb3Jpem9udGFsICYgdmVydGljYWwgbGluZXNcbiAgICBoTGluZShjLCBsZW4sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgeyB3aWR0aDogbGVuLCBoZWlnaHQ6IDEgfSwgdmFsdWUpO1xuICAgIH1cbiAgICB2TGluZShjLCBsZW4sIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlY3QoYywgeyB3aWR0aDogMSwgaGVpZ2h0OiBsZW4gfSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBhZGQgYm9yZGVyXG4gICAgYm9yZGVyKGJvcmRlciA9IDIsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuaGVpZ2h0ICsgMiAqIGJvcmRlcjtcbiAgICAgICAgY29uc3Qgd2lkdGggPSB0aGlzLndpZHRoICsgMiAqIGJvcmRlcjtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IEJpdG1hcCh7IGhlaWdodCwgd2lkdGggfSk7XG4gICAgICAgIC8vIGZpbGwgZXZlcnl0aGluZyB3aXRoIGJvcmRlciB2YWx1ZSwgdGhlbiBlbWJlZCBvcmlnaW5hbFxuICAgICAgICBvdXQucmVjdCgwLCBJbmZpbml0eSwgdmFsdWUpO1xuICAgICAgICBvdXQuZW1iZWQoeyB4OiBib3JkZXIsIHk6IGJvcmRlciB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgLy8gRW1iZWQgYW5vdGhlciBiaXRtYXAgb24gY29vcmRpbmF0ZXNcbiAgICBlbWJlZChjLCBzcmMpIHtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnh5KGMpO1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IEJpdG1hcC5zaXplKHNyYy5zaXplKCksIHRoaXMuc2l6ZSh7IHgsIHkgfSkpO1xuICAgICAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkZWZpbmVkIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCB7IHdvcmRzOiBzcmNTdHJpZGUsIHZhbHVlOiBzcmNWYWx1ZSB9ID0gc3JjO1xuICAgICAgICBmb3IgKGxldCB5UG9zID0gMDsgeVBvcyA8IGhlaWdodDsgeVBvcysrKSB7XG4gICAgICAgICAgICBjb25zdCBzcmNSb3cgPSB5UG9zICogc3JjU3RyaWRlO1xuICAgICAgICAgICAgZm9yIChsZXQgeFBvcyA9IDA7IHhQb3MgPCB3aWR0aDspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkc3RYID0geCArIHhQb3M7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3b3JkOiBkc3RXb3JkLCBiaXQ6IGRzdEJpdCB9ID0gdGhpcy5iaXRJbmRleChkc3RYLCB5ICsgeVBvcyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB3b3JkOiBzcmNXb3JkLCBiaXQ6IHNyY0JpdCB9ID0gc3JjLmJpdEluZGV4KHhQb3MsIHlQb3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IE1hdGgubWluKDMyIC0gZHN0Qml0LCB3aWR0aCAtIHhQb3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHcwID0gc3JjVmFsdWVbc3JjV29yZF07XG4gICAgICAgICAgICAgICAgY29uc3QgdzEgPSBzcmNCaXQgJiYgc3JjV29yZCArIDEgPCBzcmNSb3cgKyBzcmNTdHJpZGUgPyBzcmNWYWx1ZVtzcmNXb3JkICsgMV0gOiAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNWYWwgPSBzcmNCaXQgPyAoKHcwID4+PiBzcmNCaXQpIHwgKHcxIDw8ICgzMiAtIHNyY0JpdCkpKSA+Pj4gMCA6IHcwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRzdE1hc2sgPSByYW5nZU1hc2soZHN0Qml0LCBsZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbEJpdHMgPSAoKHNWYWwgJiByYW5nZU1hc2soMCwgbGVuKSkgPDwgZHN0Qml0KSA+Pj4gMDtcbiAgICAgICAgICAgICAgICBkZWZpbmVkW2RzdFdvcmRdIHw9IGRzdE1hc2s7XG4gICAgICAgICAgICAgICAgdmFsdWVbZHN0V29yZF0gPSAodmFsdWVbZHN0V29yZF0gJiB+ZHN0TWFzaykgfCB2YWxCaXRzO1xuICAgICAgICAgICAgICAgIHhQb3MgKz0gbGVuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHJlY3Rhbmd1bGFyIHBhcnQgb2YgYml0bWFwXG4gICAgcmVjdFNsaWNlKGMsIHNpemUgPSB0aGlzLnNpemUoKSkge1xuICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMueHkoYyk7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gQml0bWFwLnNpemUoc2l6ZSwgdGhpcy5zaXplKHsgeCwgeSB9KSk7XG4gICAgICAgIGNvbnN0IHJlY3QgPSBuZXcgQml0bWFwKHsgaGVpZ2h0LCB3aWR0aCB9KTtcbiAgICAgICAgdGhpcy5yZWN0UmVhZCh7IHgsIHkgfSwgeyBoZWlnaHQsIHdpZHRoIH0sIChwLCBjdXIpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRGVmaW5lZCh4ICsgcC54LCB5ICsgcC55KSkge1xuICAgICAgICAgICAgICAgIHJlY3Quc2V0KHAueCwgcC55LCBjdXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlY3Q7XG4gICAgfVxuICAgIC8vIENoYW5nZSBzaGFwZSwgcmVwbGFjZSByb3dzIHdpdGggY29sdW1ucyAoZGF0YVt5XVt4XSAtPiBkYXRhW3hdW3ldKVxuICAgIHRyYW5zcG9zZSgpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCB2YWx1ZSwgZGVmaW5lZCwgd29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGRzdCA9IG5ldyBCaXRtYXAoeyBoZWlnaHQ6IHdpZHRoLCB3aWR0aDogaGVpZ2h0IH0pO1xuICAgICAgICBjb25zdCB7IHdvcmRzOiBkc3RTdHJpZGUsIHZhbHVlOiBkc3RWYWx1ZSwgZGVmaW5lZDogZHN0RGVmaW5lZCwgdGFpbE1hc2s6IGRzdFRhaWwgfSA9IGRzdDtcbiAgICAgICAgY29uc3QgdG1wViA9IG5ldyBVaW50MzJBcnJheSgzMik7XG4gICAgICAgIGNvbnN0IHRtcEQgPSBuZXcgVWludDMyQXJyYXkoMzIpO1xuICAgICAgICAvLyBQcm9jZXNzIHNyYyBpbiBibG9ja3M6IHkgaW4gW2J5Li5ieSszMV0sIHggaW4gMzItYml0IHdvcmRzXG4gICAgICAgIGZvciAobGV0IGJ5ID0gMDsgYnkgPCBoZWlnaHQ7IGJ5ICs9IDMyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBieCA9IDA7IGJ4IDwgd29yZHM7IGJ4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb3dzID0gTWF0aC5taW4oMzIsIGhlaWdodCAtIGJ5KTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCByID0gMDsgciA8IHJvd3M7IHIrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB3aSA9IHRoaXMud29yZEluZGV4KDMyICogYngsIGJ5ICsgcik7XG4gICAgICAgICAgICAgICAgICAgIHRtcFZbcl0gPSB2YWx1ZVt3aV07XG4gICAgICAgICAgICAgICAgICAgIHRtcERbcl0gPSBkZWZpbmVkW3dpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gemVyby1wYWQgcmVtYWluZGVyXG4gICAgICAgICAgICAgICAgdG1wVi5maWxsKDAsIHJvd3MpO1xuICAgICAgICAgICAgICAgIHRtcEQuZmlsbCgwLCByb3dzKTtcbiAgICAgICAgICAgICAgICB0cmFuc3Bvc2UzMih0bXBWKTtcbiAgICAgICAgICAgICAgICB0cmFuc3Bvc2UzMih0bXBEKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZHN0WSA9IGJ4ICogMzIgKyBpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZHN0WSA+PSB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkc3RQb3MgPSBkc3Qud29yZEluZGV4KGJ5LCBkc3RZKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyTWFzayA9IGJ5ID4+PiA1ID09PSBkc3RTdHJpZGUgLSAxID8gZHN0VGFpbCA6IDB4ZmZmZmZmZmY7XG4gICAgICAgICAgICAgICAgICAgIGRzdFZhbHVlW2RzdFBvc10gPSB0bXBWW2ldICYgY3VyTWFzaztcbiAgICAgICAgICAgICAgICAgICAgZHN0RGVmaW5lZFtkc3RQb3NdID0gdG1wRFtpXSAmIGN1ck1hc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgfVxuICAgIC8vIGJsYWNrIDwtPiB3aGl0ZSAoaW5wbGFjZSlcbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIGNvbnN0IG4gPSB0aGlzLmRlZmluZWQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVtpXSA9IH50aGlzLnZhbHVlW2ldO1xuICAgICAgICAgICAgdGhpcy5kZWZpbmVkW2ldID0gMHhmZmZmZmZmZjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gRWFjaCBwaXhlbCBzaXplIGlzIG11bHRpcGxpZWQgYnkgZmFjdG9yXG4gICAgc2NhbGUoZmFjdG9yKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIoZmFjdG9yKSB8fCBmYWN0b3IgPiAxMDI0KVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHNjYWxlIGZhY3RvcjogJHtmYWN0b3J9YCk7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCB9ID0gdGhpcztcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEJpdG1hcCh7IGhlaWdodDogZmFjdG9yICogaGVpZ2h0LCB3aWR0aDogZmFjdG9yICogd2lkdGggfSk7XG4gICAgICAgIHJldHVybiByZXMucmVjdCh7IHg6IDAsIHk6IDAgfSwgSW5maW5pdHksICh7IHgsIHkgfSkgPT4gdGhpcy5nZXQoKHggLyBmYWN0b3IpIHwgMCwgKHkgLyBmYWN0b3IpIHwgMCkpO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgY29uc3QgcmVzID0gbmV3IEJpdG1hcCh0aGlzLnNpemUoKSk7XG4gICAgICAgIHJlcy5kZWZpbmVkLnNldCh0aGlzLmRlZmluZWQpO1xuICAgICAgICByZXMudmFsdWUuc2V0KHRoaXMudmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICAvLyBFbnN1cmUgdGhhdCB0aGVyZSBpcyBubyB1bmRlZmluZWQgdmFsdWVzIGxlZnRcbiAgICBhc3NlcnREcmF3bigpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoLCBkZWZpbmVkLCB0YWlsTWFzaywgZnVsbFdvcmRzLCB3b3JkcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFoZWlnaHQgfHwgIXdpZHRoKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3dCYXNlID0geSAqIHdvcmRzO1xuICAgICAgICAgICAgZm9yIChsZXQgd2kgPSAwOyB3aSA8IGZ1bGxXb3Jkczsgd2krKykge1xuICAgICAgICAgICAgICAgIGlmIChkZWZpbmVkW3Jvd0Jhc2UgKyB3aV0gIT09IDB4ZmZmZmZmZmYpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciB0eXBlPXVuZGVmaW5lZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdvcmRzICE9PSBmdWxsV29yZHMgJiYgKGRlZmluZWRbcm93QmFzZSArIGZ1bGxXb3Jkc10gJiB0YWlsTWFzaykgIT09IHRhaWxNYXNrKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciB0eXBlPXVuZGVmaW5lZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvdW50UGF0dGVybkluUm93KHksIHBhdHRlcm5MZW4sIC4uLnBhdHRlcm5zKSB7XG4gICAgICAgIGlmIChwYXR0ZXJuTGVuIDw9IDAgfHwgcGF0dGVybkxlbiA+PSAzMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignd3JvbmcgcGF0dGVybkxlbicpO1xuICAgICAgICBjb25zdCBtYXNrID0gKDEgPDwgcGF0dGVybkxlbikgLSAxO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCB2YWx1ZSwgd29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgIGNvbnN0IHJvd0Jhc2UgPSB0aGlzLndvcmRJbmRleCgwLCB5KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIHdpbmRvdyA9IDA7IGkgPCB3b3JkczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB3ID0gdmFsdWVbcm93QmFzZSArIGldO1xuICAgICAgICAgICAgY29uc3QgYml0RW5kID0gaSA9PT0gd29yZHMgLSAxID8gd2lkdGggJiAzMSB8fCAzMiA6IDMyO1xuICAgICAgICAgICAgZm9yIChsZXQgYiA9IDA7IGIgPCBiaXRFbmQ7IGIrKykge1xuICAgICAgICAgICAgICAgIHdpbmRvdyA9ICgod2luZG93IDw8IDEpIHwgKCh3ID4+PiBiKSAmIDEpKSAmIG1hc2s7XG4gICAgICAgICAgICAgICAgaWYgKGkgKiAzMiArIGIgKyAxIDwgcGF0dGVybkxlbilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBwIG9mIHBhdHRlcm5zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh3aW5kb3cgIT09IHApXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgY291bnQrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgZ2V0UnVucyh5LCBmbikge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCB2YWx1ZSwgd29yZHMgfSA9IHRoaXM7XG4gICAgICAgIGlmICh3aWR0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbGV0IHJ1bkxlbiA9IDA7XG4gICAgICAgIGxldCBydW5WYWx1ZTtcbiAgICAgICAgY29uc3Qgcm93QmFzZSA9IHRoaXMud29yZEluZGV4KDAsIHkpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmQgPSB2YWx1ZVtyb3dCYXNlICsgaV07XG4gICAgICAgICAgICBjb25zdCBiaXRFbmQgPSBpID09PSB3b3JkcyAtIDEgPyB3aWR0aCAmIDMxIHx8IDMyIDogMzI7XG4gICAgICAgICAgICBmb3IgKGxldCBiID0gMDsgYiA8IGJpdEVuZDsgYisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0ID0gKHdvcmQgJiAoMSA8PCBiKSkgIT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKGJpdCA9PT0gcnVuVmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVuTGVuKys7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVuVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgZm4ocnVuTGVuLCBydW5WYWx1ZSk7XG4gICAgICAgICAgICAgICAgcnVuVmFsdWUgPSBiaXQ7XG4gICAgICAgICAgICAgICAgcnVuTGVuID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocnVuVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGZuKHJ1bkxlbiwgcnVuVmFsdWUpO1xuICAgIH1cbiAgICBwb3BjbnQoKSB7XG4gICAgICAgIGNvbnN0IHsgaGVpZ2h0LCB3aWR0aCwgd29yZHMsIGZ1bGxXb3JkcywgdGFpbE1hc2sgfSA9IHRoaXM7XG4gICAgICAgIGlmICghaGVpZ2h0IHx8ICF3aWR0aClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3dCYXNlID0geSAqIHdvcmRzO1xuICAgICAgICAgICAgZm9yIChsZXQgd2kgPSAwOyB3aSA8IGZ1bGxXb3Jkczsgd2krKylcbiAgICAgICAgICAgICAgICBjb3VudCArPSBwb3BjbnQodGhpcy52YWx1ZVtyb3dCYXNlICsgd2ldKTtcbiAgICAgICAgICAgIGlmICh3b3JkcyAhPT0gZnVsbFdvcmRzKVxuICAgICAgICAgICAgICAgIGNvdW50ICs9IHBvcGNudCh0aGlzLnZhbHVlW3Jvd0Jhc2UgKyBmdWxsV29yZHNdICYgdGFpbE1hc2spO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9XG4gICAgY291bnRCb3hlczJ4Mih5KSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIHdvcmRzIH0gPSB0aGlzO1xuICAgICAgICBpZiAod2lkdGggPCAyIHx8ICh5IHwgMCkgPCAwIHx8IHkgKyAxID49IHRoaXMuaGVpZ2h0KVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IGJhc2UwID0gdGhpcy53b3JkSW5kZXgoMCwgeSkgfCAwO1xuICAgICAgICBjb25zdCBiYXNlMSA9IHRoaXMud29yZEluZGV4KDAsIHkgKyAxKSB8IDA7XG4gICAgICAgIC8vIHZhbGlkIFwibGVmdC1lZGdlXCIgcG9zaXRpb25zIHggaW4gWzAgLi4gVy0yXVxuICAgICAgICBjb25zdCB0YWlsQml0cyA9IHdpZHRoICYgMzE7XG4gICAgICAgIGNvbnN0IHZhbGlkTGFzdCA9IHRhaWxCaXRzID09PSAwID8gMHg3ZmZmZmZmZiA6IHJhbmdlTWFzaygwLCAod2lkdGggLSAxKSAmIDMxKTtcbiAgICAgICAgbGV0IGJveGVzID0gMDtcbiAgICAgICAgZm9yIChsZXQgd2kgPSAwOyB3aSA8IHdvcmRzOyB3aSsrKSB7XG4gICAgICAgICAgICBjb25zdCBhMCA9IHRoaXMudmFsdWVbYmFzZTAgKyB3aV07XG4gICAgICAgICAgICBjb25zdCBhMSA9IHRoaXMudmFsdWVbYmFzZTEgKyB3aV07XG4gICAgICAgICAgICAvLyBDb21wYXJlIGJpdCB4IHdpdGggYml0IHgrMSBhdCBzYW1lIGJpdCBwb3NpdGlvbi5cbiAgICAgICAgICAgIGNvbnN0IGVxViA9IH4oYTAgXiBhMSkgPj4+IDA7IC8vIHJvdzBbeF0gPT0gcm93MVt4XVxuICAgICAgICAgICAgY29uc3QgbjAgPSB3aSArIDEgPCB3b3JkcyA/IHRoaXMudmFsdWVbYmFzZTAgKyB3aSArIDFdID4+PiAwIDogMDtcbiAgICAgICAgICAgIGNvbnN0IGVxSDAgPSB+KGEwIF4gKCgoYTAgPj4+IDEpIHwgKChuMCAmIDEpIDw8IDMxKSkgPj4+IDApKSA+Pj4gMDsgLy8gcm93MFt4XSA9PSByb3cwW3grMV1cbiAgICAgICAgICAgIGNvbnN0IG4xID0gd2kgKyAxIDwgd29yZHMgPyB0aGlzLnZhbHVlW2Jhc2UxICsgd2kgKyAxXSA+Pj4gMCA6IDA7XG4gICAgICAgICAgICBjb25zdCBlcUgxID0gfihhMSBeICgoKGExID4+PiAxKSB8ICgobjEgJiAxKSA8PCAzMSkpID4+PiAwKSkgPj4+IDA7IC8vIHJvdzFbeF0gPT0gcm93MVt4KzFdXG4gICAgICAgICAgICBsZXQgbSA9IChlcVYgJiBlcUgwICYgZXFIMSkgPj4+IDA7XG4gICAgICAgICAgICBpZiAod2kgPT09IHdvcmRzIC0gMSlcbiAgICAgICAgICAgICAgICBtICY9IHZhbGlkTGFzdDtcbiAgICAgICAgICAgIGJveGVzICs9IHBvcGNudChtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYm94ZXM7XG4gICAgfVxuICAgIC8vIEV4cG9ydFxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBjb25zdCBubCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hDb2Rlcy5uZXdsaW5lKTtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGxldCBsaW5lID0gJyc7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHYgPSB0aGlzLmdldCh4LCB5KTtcbiAgICAgICAgICAgICAgICBsaW5lICs9ICF0aGlzLmlzRGVmaW5lZCh4LCB5KSA/ICc/JyA6IHYgPyAnWCcgOiAnICc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gbGluZSArICh5ICsgMSA9PT0gdGhpcy5oZWlnaHQgPyAnJyA6IG5sKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0b1JhdygpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gQXJyYXkuZnJvbSh7IGxlbmd0aDogdGhpcy5oZWlnaHQgfSwgKCkgPT4gbmV3IEFycmF5KHRoaXMud2lkdGgpKTtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCB0aGlzLmhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBjb25zdCByb3cgPSBvdXRbeV07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHRoaXMud2lkdGg7IHgrKylcbiAgICAgICAgICAgICAgICByb3dbeF0gPSB0aGlzLmdldCh4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0b0FTQ0lJKCkge1xuICAgICAgICBjb25zdCB7IGhlaWdodCwgd2lkdGggfSA9IHRoaXM7XG4gICAgICAgIGxldCBvdXQgPSAnJztcbiAgICAgICAgLy8gVGVybWluYWwgY2hhcmFjdGVyIGhlaWdodCBpcyB4MiBvZiBjaGFyYWN0ZXIgd2lkdGgsIHNvIHdlIHByb2Nlc3MgdHdvIHJvd3Mgb2YgYml0bWFwXG4gICAgICAgIC8vIHRvIHByb2R1Y2Ugb25lIHJvdyBvZiBBU0NJSVxuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSArPSAyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdCA9IHRoaXMuZ2V0KHgsIHkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlY29uZCA9IHkgKyAxID49IGhlaWdodCA/IHRydWUgOiB0aGlzLmdldCh4LCB5ICsgMSk7IC8vIGlmIGxhc3Qgcm93IG91dHNpZGUgYml0bWFwLCBtYWtlIGl0IGJsYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmaXJzdCAmJiAhc2Vjb25kKVxuICAgICAgICAgICAgICAgICAgICBvdXQgKz0gJ+KWiCc7IC8vIGJvdGggcm93cyB3aGl0ZSAoZW1wdHkpXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWZpcnN0ICYmIHNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICfiloAnOyAvLyB0b3Agcm93IHdoaXRlXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmlyc3QgJiYgIXNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICfiloQnOyAvLyBkb3duIHJvdyB3aGl0ZVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpcnN0ICYmIHNlY29uZClcbiAgICAgICAgICAgICAgICAgICAgb3V0ICs9ICcgJzsgLy8gYm90aCByb3dzIGJsYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjaENvZGVzLm5ld2xpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuICAgIHRvVGVybSgpIHtcbiAgICAgICAgY29uc3QgY2MgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoQ29kZXMucmVzZXQpO1xuICAgICAgICBjb25zdCByZXNldCA9IGNjICsgJ1swbSc7XG4gICAgICAgIGNvbnN0IHdoaXRlQkcgPSBjYyArICdbMTs0N20gICcgKyByZXNldDtcbiAgICAgICAgY29uc3QgZGFya0JHID0gY2MgKyBgWzQwbSAgYCArIHJlc2V0O1xuICAgICAgICBjb25zdCBubCA9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hDb2Rlcy5uZXdsaW5lKTtcbiAgICAgICAgbGV0IG91dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IHRoaXMuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuZ2V0KHgsIHkpOyAvLyB1bmRlZmluZWQgLT4gd2hpdGVcbiAgICAgICAgICAgICAgICBvdXQgKz0gdiA/IGRhcmtCRyA6IHdoaXRlQkc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXQgKz0gbmw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgdG9TVkcob3B0aW1pemUgPSB0cnVlKSB7XG4gICAgICAgIGxldCBvdXQgPSBgPHN2ZyB2aWV3Qm94PVwiMCAwICR7dGhpcy53aWR0aH0gJHt0aGlzLmhlaWdodH1cIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+YDtcbiAgICAgICAgLy8gQ29uc3RydWN0IG9wdGltaXplZCBTVkcgcGF0aCBkYXRhLlxuICAgICAgICBsZXQgcGF0aERhdGEgPSAnJztcbiAgICAgICAgbGV0IHByZXZQb2ludDtcbiAgICAgICAgdGhpcy5yZWN0UmVhZCgwLCBJbmZpbml0eSwgKHBvaW50LCB2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICghdmFsKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gcG9pbnQ7XG4gICAgICAgICAgICBpZiAoIW9wdGltaXplKSB7XG4gICAgICAgICAgICAgICAgb3V0ICs9IGA8cmVjdCB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIC8+YDtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvUmVmZXJlbmNlL0F0dHJpYnV0ZS9kI3BhdGhfY29tbWFuZHNcbiAgICAgICAgICAgIC8vIERldGVybWluZSB0aGUgc2hvcnRlc3Qgd2F5IHRvIHJlcHJlc2VudCB0aGUgaW5pdGlhbCBjdXJzb3IgbW92ZW1lbnQuXG4gICAgICAgICAgICAvLyBNIC0gTW92ZSBjdXJzb3IgKHdpdGhvdXQgZHJhd2luZykgdG8gYWJzb2x1dGUgY29vcmRpbmF0ZSBwYWlyLlxuICAgICAgICAgICAgbGV0IG0gPSBgTSR7eH0gJHt5fWA7XG4gICAgICAgICAgICAvLyBPbmx5IGFsbG93IHVzaW5nIHRoZSByZWxhdGl2ZSBjdXJzb3IgbW92ZSBjb21tYW5kIGlmIHByZXZpb3VzIHBvaW50c1xuICAgICAgICAgICAgLy8gd2VyZSBkcmF3bi5cbiAgICAgICAgICAgIGlmIChwcmV2UG9pbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBtIC0gTW92ZSBjdXJzb3IgKHdpdGhvdXQgZHJhd2luZykgdG8gcmVsYXRpdmUgY29vcmRpbmF0ZSBwYWlyLlxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbE0gPSBgbSR7eCAtIHByZXZQb2ludC54fSAke3kgLSBwcmV2UG9pbnQueX1gO1xuICAgICAgICAgICAgICAgIGlmIChyZWxNLmxlbmd0aCA8PSBtLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgbSA9IHJlbE07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNob3J0ZXN0IHdheSB0byByZXByZXNlbnQgdGhlIGNlbGwncyBib3R0b20gbGluZSBkcmF3LlxuICAgICAgICAgICAgLy8gSCAtIERyYXcgbGluZSBmcm9tIGN1cnNvciBwb3NpdGlvbiB0byBhYnNvbHV0ZSB4IGNvb3JkaW5hdGUuXG4gICAgICAgICAgICAvLyBoIC0gRHJhdyBsaW5lIGZyb20gY3Vyc29yIHBvc2l0aW9uIHRvIHJlbGF0aXZlIHggY29vcmRpbmF0ZS5cbiAgICAgICAgICAgIGNvbnN0IGJIID0geCA8IDEwID8gYEgke3h9YCA6ICdoLTEnO1xuICAgICAgICAgICAgLy8gdiAtIERyYXcgbGluZSBmcm9tIGN1cnNvciBwb3NpdGlvbiB0byByZWxhdGl2ZSB5IGNvb3JkaW5hdGUuXG4gICAgICAgICAgICAvLyBaIC0gQ2xvc2UgcGF0aCAoZHJhd3MgbGluZSBmcm9tIGN1cnNvciBwb3NpdGlvbiB0byBNIGNvb3JkaW5hdGUpLlxuICAgICAgICAgICAgcGF0aERhdGEgKz0gYCR7bX1oMXYxJHtiSH1aYDtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9wdGltaXplKVxuICAgICAgICAgICAgb3V0ICs9IGA8cGF0aCBkPVwiJHtwYXRoRGF0YX1cIi8+YDtcbiAgICAgICAgb3V0ICs9IGA8L3N2Zz5gO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB0b0dJRigpIHtcbiAgICAgICAgLy8gTk9URTogU21hbGwsIGJ1dCBpbmVmZmljaWVudCBpbXBsZW1lbnRhdGlvbi5cbiAgICAgICAgLy8gVXNlcyAxIGJ5dGUgcGVyIHBpeGVsLlxuICAgICAgICBjb25zdCB1MTZsZSA9IChpKSA9PiBbaSAmIDB4ZmYsIChpID4+PiA4KSAmIDB4ZmZdO1xuICAgICAgICBjb25zdCBkaW1zID0gWy4uLnUxNmxlKHRoaXMud2lkdGgpLCAuLi51MTZsZSh0aGlzLmhlaWdodCldO1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIHRoaXMucmVjdFJlYWQoMCwgSW5maW5pdHksIChfLCBjdXIpID0+IGRhdGEucHVzaCgrKGN1ciA9PT0gdHJ1ZSkpKTtcbiAgICAgICAgY29uc3QgTiA9IDEyNjsgLy8gQmxvY2sgc2l6ZVxuICAgICAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBbXG4gICAgICAgICAgICAweDQ3LCAweDQ5LCAweDQ2LCAweDM4LCAweDM3LCAweDYxLCAuLi5kaW1zLCAweGY2LCAweDAwLCAweDAwLCAweGZmLCAweGZmLCAweGZmLFxuICAgICAgICAgICAgLi4uZmlsbEFycigzICogMTI3LCAweDAwKSwgMHgyYywgMHgwMCwgMHgwMCwgMHgwMCwgMHgwMCwgLi4uZGltcywgMHgwMCwgMHgwN1xuICAgICAgICBdO1xuICAgICAgICBjb25zdCBmdWxsQ2h1bmtzID0gTWF0aC5mbG9vcihkYXRhLmxlbmd0aCAvIE4pO1xuICAgICAgICAvLyBGdWxsIGJsb2Nrc1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZ1bGxDaHVua3M7IGkrKylcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goTiArIDEsIDB4ODAsIC4uLmRhdGEuc2xpY2UoTiAqIGksIE4gKiAoaSArIDEpKS5tYXAoKGkpID0+ICtpKSk7XG4gICAgICAgIC8vIFJlbWFpbmluZyBieXRlc1xuICAgICAgICBieXRlcy5wdXNoKChkYXRhLmxlbmd0aCAlIE4pICsgMSwgMHg4MCwgLi4uZGF0YS5zbGljZShmdWxsQ2h1bmtzICogTikubWFwKChpKSA9PiAraSkpO1xuICAgICAgICBieXRlcy5wdXNoKDB4MDEsIDB4ODEsIDB4MDAsIDB4M2IpO1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICAgIH1cbiAgICB0b0ltYWdlKGlzUkdCID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgeyBoZWlnaHQsIHdpZHRoIH0gPSB0aGlzLnNpemUoKTtcbiAgICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGhlaWdodCAqIHdpZHRoICogKGlzUkdCID8gMyA6IDQpKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZ2V0KHgsIHkpID8gMCA6IDI1NTsgLy8gdW5kZWZpbmVkIC0+IHdoaXRlXG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgZGF0YVtpKytdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1JHQilcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtpKytdID0gMjU1OyAvLyBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaGVpZ2h0LCB3aWR0aCwgZGF0YSB9O1xuICAgIH1cbn1cbi8vIEVuZCBvZiB1dGlsc1xuLy8gUnVudGltZSB0eXBlLWNoZWNraW5nXG4vKiogRXJyb3IgY29ycmVjdGlvbiBtb2RlLiBsb3c6IDclLCBtZWRpdW06IDE1JSwgcXVhcnRpbGU6IDI1JSwgaGlnaDogMzAlICovXG5leHBvcnQgY29uc3QgRUNNb2RlID0gWydsb3cnLCAnbWVkaXVtJywgJ3F1YXJ0aWxlJywgJ2hpZ2gnXTtcbi8qKiBRUiBDb2RlIGVuY29kaW5nICovXG5leHBvcnQgY29uc3QgRW5jb2RpbmcgPSBbJ251bWVyaWMnLCAnYWxwaGFudW1lcmljJywgJ2J5dGUnLCAna2FuamknLCAnZWNpJ107XG4vLyBWYXJpb3VzIGNvbnN0YW50cyAmIHRhYmxlc1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBCWVRFUyA9IFtcbiAgICAvLyAxLCAgMiwgIDMsICAgNCwgICA1LCAgIDYsICAgNywgICA4LCAgIDksICAxMCwgIDExLCAgMTIsICAxMywgIDE0LCAgMTUsICAxNiwgIDE3LCAgMTgsICAxOSwgICAyMCxcbiAgICAyNiwgNDQsIDcwLCAxMDAsIDEzNCwgMTcyLCAxOTYsIDI0MiwgMjkyLCAzNDYsIDQwNCwgNDY2LCA1MzIsIDU4MSwgNjU1LCA3MzMsIDgxNSwgOTAxLCA5OTEsIDEwODUsXG4gICAgLy8gIDIxLCAgIDIyLCAgIDIzLCAgIDI0LCAgIDI1LCAgIDI2LCAgIDI3LCAgIDI4LCAgIDI5LCAgIDMwLCAgIDMxLCAgIDMyLCAgIDMzLCAgIDM0LCAgIDM1LCAgIDM2LCAgIDM3LCAgIDM4LCAgIDM5LCAgIDQwXG4gICAgMTE1NiwgMTI1OCwgMTM2NCwgMTQ3NCwgMTU4OCwgMTcwNiwgMTgyOCwgMTkyMSwgMjA1MSwgMjE4NSwgMjMyMywgMjQ2NSwgMjYxMSwgMjc2MSwgMjg3NiwgMzAzNCwgMzE5NiwgMzM2MiwgMzUzMiwgMzcwNixcbl07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFdPUkRTX1BFUl9CTE9DSyA9IHtcbiAgICAvLyBWZXJzaW9uIDEsICAyLCAgMywgIDQsICA1LCAgNiwgIDcsICA4LCAgOSwgMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDBcbiAgICBsb3c6IFs3LCAxMCwgMTUsIDIwLCAyNiwgMTgsIDIwLCAyNCwgMzAsIDE4LCAyMCwgMjQsIDI2LCAzMCwgMjIsIDI0LCAyOCwgMzAsIDI4LCAyOCwgMjgsIDI4LCAzMCwgMzAsIDI2LCAyOCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbiAgICBtZWRpdW06IFsxMCwgMTYsIDI2LCAxOCwgMjQsIDE2LCAxOCwgMjIsIDIyLCAyNiwgMzAsIDIyLCAyMiwgMjQsIDI0LCAyOCwgMjgsIDI2LCAyNiwgMjYsIDI2LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOCwgMjgsIDI4LCAyOF0sXG4gICAgcXVhcnRpbGU6IFsxMywgMjIsIDE4LCAyNiwgMTgsIDI0LCAxOCwgMjIsIDIwLCAyNCwgMjgsIDI2LCAyNCwgMjAsIDMwLCAyNCwgMjgsIDI4LCAyNiwgMzAsIDI4LCAzMCwgMzAsIDMwLCAzMCwgMjgsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMF0sXG4gICAgaGlnaDogWzE3LCAyOCwgMjIsIDE2LCAyMiwgMjgsIDI2LCAyNiwgMjQsIDI4LCAyNCwgMjgsIDIyLCAyNCwgMjQsIDMwLCAyOCwgMjgsIDI2LCAyOCwgMzAsIDI0LCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwLCAzMCwgMzAsIDMwXSxcbn07XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IEVDQ19CTE9DS1MgPSB7XG4gICAgLy8gVmVyc2lvbiAgIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksMTAsIDExLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDIwLCAyMSwgMjIsIDIzLCAyNCwgMjUsIDI2LCAyNywgMjgsIDI5LCAzMCwgMzEsIDMyLCAzMywgMzQsIDM1LCAzNiwgMzcsIDM4LCAzOSwgNDBcbiAgICBsb3c6IFsxLCAxLCAxLCAxLCAxLCAyLCAyLCAyLCAyLCA0LCA0LCA0LCA0LCA0LCA2LCA2LCA2LCA2LCA3LCA4LCA4LCA5LCA5LCAxMCwgMTIsIDEyLCAxMiwgMTMsIDE0LCAxNSwgMTYsIDE3LCAxOCwgMTksIDE5LCAyMCwgMjEsIDIyLCAyNCwgMjVdLFxuICAgIG1lZGl1bTogWzEsIDEsIDEsIDIsIDIsIDQsIDQsIDQsIDUsIDUsIDUsIDgsIDksIDksIDEwLCAxMCwgMTEsIDEzLCAxNCwgMTYsIDE3LCAxNywgMTgsIDIwLCAyMSwgMjMsIDI1LCAyNiwgMjgsIDI5LCAzMSwgMzMsIDM1LCAzNywgMzgsIDQwLCA0MywgNDUsIDQ3LCA0OV0sXG4gICAgcXVhcnRpbGU6IFsxLCAxLCAyLCAyLCA0LCA0LCA2LCA2LCA4LCA4LCA4LCAxMCwgMTIsIDE2LCAxMiwgMTcsIDE2LCAxOCwgMjEsIDIwLCAyMywgMjMsIDI1LCAyNywgMjksIDM0LCAzNCwgMzUsIDM4LCA0MCwgNDMsIDQ1LCA0OCwgNTEsIDUzLCA1NiwgNTksIDYyLCA2NSwgNjhdLFxuICAgIGhpZ2g6IFsxLCAxLCAyLCA0LCA0LCA0LCA1LCA2LCA4LCA4LCAxMSwgMTEsIDE2LCAxNiwgMTgsIDE2LCAxOSwgMjEsIDI1LCAyNSwgMjUsIDM0LCAzMCwgMzIsIDM1LCAzNywgNDAsIDQyLCA0NSwgNDgsIDUxLCA1NCwgNTcsIDYwLCA2MywgNjYsIDcwLCA3NCwgNzcsIDgxXSxcbn07XG5jb25zdCBpbmZvID0ge1xuICAgIHNpemU6IHtcbiAgICAgICAgZW5jb2RlOiAodmVyKSA9PiAyMSArIDQgKiAodmVyIC0gMSksIC8vIHZlcjEgPSAyMSwgdmVyNDA9MTc3IGJsb2Nrc1xuICAgICAgICBkZWNvZGU6IChzaXplKSA9PiAoc2l6ZSAtIDE3KSAvIDQsXG4gICAgfSxcbiAgICBzaXplVHlwZTogKHZlcikgPT4gTWF0aC5mbG9vcigodmVyICsgNykgLyAxNyksXG4gICAgLy8gQmFzZWQgb24gaHR0cHM6Ly9jb2RlcmV2aWV3LnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy83NDkyNS9hbGdvcml0aG0tdG8tZ2VuZXJhdGUtdGhpcy1hbGlnbm1lbnQtcGF0dGVybi1sb2NhdGlvbnMtdGFibGUtZm9yLXFyLWNvZGVzXG4gICAgYWxpZ25tZW50UGF0dGVybnModmVyKSB7XG4gICAgICAgIGlmICh2ZXIgPT09IDEpXG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIGNvbnN0IGZpcnN0ID0gNjtcbiAgICAgICAgY29uc3QgbGFzdCA9IGluZm8uc2l6ZS5lbmNvZGUodmVyKSAtIGZpcnN0IC0gMTtcbiAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBsYXN0IC0gZmlyc3Q7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gTWF0aC5jZWlsKGRpc3RhbmNlIC8gMjgpO1xuICAgICAgICBsZXQgaW50ZXJ2YWwgPSBNYXRoLmZsb29yKGRpc3RhbmNlIC8gY291bnQpO1xuICAgICAgICBpZiAoaW50ZXJ2YWwgJSAyKVxuICAgICAgICAgICAgaW50ZXJ2YWwgKz0gMTtcbiAgICAgICAgZWxzZSBpZiAoKGRpc3RhbmNlICUgY291bnQpICogMiA+PSBjb3VudClcbiAgICAgICAgICAgIGludGVydmFsICs9IDI7XG4gICAgICAgIGNvbnN0IHJlcyA9IFtmaXJzdF07XG4gICAgICAgIGZvciAobGV0IG0gPSAxOyBtIDwgY291bnQ7IG0rKylcbiAgICAgICAgICAgIHJlcy5wdXNoKGxhc3QgLSAoY291bnQgLSBtKSAqIGludGVydmFsKTtcbiAgICAgICAgcmVzLnB1c2gobGFzdCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICBFQ0NvZGU6IHtcbiAgICAgICAgbG93OiAwYjAxLFxuICAgICAgICBtZWRpdW06IDBiMDAsXG4gICAgICAgIHF1YXJ0aWxlOiAwYjExLFxuICAgICAgICBoaWdoOiAwYjEwLFxuICAgIH0sXG4gICAgZm9ybWF0TWFzazogMGIxMDEwMTAwMDAwMTAwMTAsXG4gICAgZm9ybWF0Qml0cyhlY2MsIG1hc2tJZHgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IChpbmZvLkVDQ29kZVtlY2NdIDw8IDMpIHwgbWFza0lkeDtcbiAgICAgICAgbGV0IGQgPSBkYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspXG4gICAgICAgICAgICBkID0gKGQgPDwgMSkgXiAoKGQgPj4gOSkgKiAwYjEwMTAwMTEwMTExKTtcbiAgICAgICAgcmV0dXJuICgoZGF0YSA8PCAxMCkgfCBkKSBeIGluZm8uZm9ybWF0TWFzaztcbiAgICB9LFxuICAgIHZlcnNpb25CaXRzKHZlcikge1xuICAgICAgICBsZXQgZCA9IHZlcjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMjsgaSsrKVxuICAgICAgICAgICAgZCA9IChkIDw8IDEpIF4gKChkID4+IDExKSAqIDBiMTExMTEwMDEwMDEwMSk7XG4gICAgICAgIHJldHVybiAodmVyIDw8IDEyKSB8IGQ7XG4gICAgfSxcbiAgICBhbHBoYWJldDoge1xuICAgICAgICBudW1lcmljOiBhbHBoYWJldCgnMDEyMzQ1Njc4OScpLFxuICAgICAgICBhbHBoYW51bWVyYzogYWxwaGFiZXQoJzAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWiAkJSorLS4vOicpLFxuICAgIH0sIC8vIGFzIFJlY29yZDxFbmNvZGluZ1R5cGUsIFJldHVyblR5cGU8dHlwZW9mIGFscGhhYmV0Pj4sXG4gICAgbGVuZ3RoQml0cyh2ZXIsIHR5cGUpIHtcbiAgICAgICAgY29uc3QgdGFibGUgPSB7XG4gICAgICAgICAgICBudW1lcmljOiBbMTAsIDEyLCAxNF0sXG4gICAgICAgICAgICBhbHBoYW51bWVyaWM6IFs5LCAxMSwgMTNdLFxuICAgICAgICAgICAgYnl0ZTogWzgsIDE2LCAxNl0sXG4gICAgICAgICAgICBrYW5qaTogWzgsIDEwLCAxMl0sXG4gICAgICAgICAgICBlY2k6IFswLCAwLCAwXSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRhYmxlW3R5cGVdW2luZm8uc2l6ZVR5cGUodmVyKV07XG4gICAgfSxcbiAgICBtb2RlQml0czoge1xuICAgICAgICBudW1lcmljOiAnMDAwMScsXG4gICAgICAgIGFscGhhbnVtZXJpYzogJzAwMTAnLFxuICAgICAgICBieXRlOiAnMDEwMCcsXG4gICAgICAgIGthbmppOiAnMTAwMCcsXG4gICAgICAgIGVjaTogJzAxMTEnLFxuICAgIH0sXG4gICAgY2FwYWNpdHkodmVyLCBlY2MpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBCWVRFU1t2ZXIgLSAxXTtcbiAgICAgICAgY29uc3Qgd29yZHMgPSBXT1JEU19QRVJfQkxPQ0tbZWNjXVt2ZXIgLSAxXTtcbiAgICAgICAgY29uc3QgbnVtQmxvY2tzID0gRUNDX0JMT0NLU1tlY2NdW3ZlciAtIDFdO1xuICAgICAgICBjb25zdCBibG9ja0xlbiA9IE1hdGguZmxvb3IoYnl0ZXMgLyBudW1CbG9ja3MpIC0gd29yZHM7XG4gICAgICAgIGNvbnN0IHNob3J0QmxvY2tzID0gbnVtQmxvY2tzIC0gKGJ5dGVzICUgbnVtQmxvY2tzKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHdvcmRzLFxuICAgICAgICAgICAgbnVtQmxvY2tzLFxuICAgICAgICAgICAgc2hvcnRCbG9ja3MsXG4gICAgICAgICAgICBibG9ja0xlbixcbiAgICAgICAgICAgIGNhcGFjaXR5OiAoYnl0ZXMgLSB3b3JkcyAqIG51bUJsb2NrcykgKiA4LFxuICAgICAgICAgICAgdG90YWw6ICh3b3JkcyArIGJsb2NrTGVuKSAqIG51bUJsb2NrcyArIG51bUJsb2NrcyAtIHNob3J0QmxvY2tzLFxuICAgICAgICB9O1xuICAgIH0sXG59O1xuY29uc3QgUEFUVEVSTlMgPSBbXG4gICAgKHgsIHkpID0+ICh4ICsgeSkgJSAyID09IDAsXG4gICAgKF94LCB5KSA9PiB5ICUgMiA9PSAwLFxuICAgICh4LCBfeSkgPT4geCAlIDMgPT0gMCxcbiAgICAoeCwgeSkgPT4gKHggKyB5KSAlIDMgPT0gMCxcbiAgICAoeCwgeSkgPT4gKE1hdGguZmxvb3IoeSAvIDIpICsgTWF0aC5mbG9vcih4IC8gMykpICUgMiA9PSAwLFxuICAgICh4LCB5KSA9PiAoKHggKiB5KSAlIDIpICsgKCh4ICogeSkgJSAzKSA9PSAwLFxuICAgICh4LCB5KSA9PiAoKCh4ICogeSkgJSAyKSArICgoeCAqIHkpICUgMykpICUgMiA9PSAwLFxuICAgICh4LCB5KSA9PiAoKCh4ICsgeSkgJSAyKSArICgoeCAqIHkpICUgMykpICUgMiA9PSAwLFxuXTtcbi8vIEdhbG9pcyBmaWVsZCAmJiByZWVkLXNvbG9tb24gZW5jb2RpbmdcbmNvbnN0IEdGID0ge1xuICAgIHRhYmxlczogKChwX3BvbHkpID0+IHtcbiAgICAgICAgY29uc3QgZXhwID0gZmlsbEFycigyNTYsIDApO1xuICAgICAgICBjb25zdCBsb2cgPSBmaWxsQXJyKDI1NiwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCB4ID0gMTsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgICAgICBleHBbaV0gPSB4O1xuICAgICAgICAgICAgbG9nW3hdID0gaTtcbiAgICAgICAgICAgIHggPDw9IDE7XG4gICAgICAgICAgICBpZiAoeCAmIDB4MTAwKVxuICAgICAgICAgICAgICAgIHggXj0gcF9wb2x5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGV4cCwgbG9nIH07XG4gICAgfSkoMHgxMWQpLFxuICAgIGV4cDogKHgpID0+IEdGLnRhYmxlcy5leHBbeF0sXG4gICAgbG9nKHgpIHtcbiAgICAgICAgaWYgKHggPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdGLmxvZzogaW52YWxpZCBhcmc9JHt4fWApO1xuICAgICAgICByZXR1cm4gR0YudGFibGVzLmxvZ1t4XSAlIDI1NTtcbiAgICB9LFxuICAgIG11bCh4LCB5KSB7XG4gICAgICAgIGlmICh4ID09PSAwIHx8IHkgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgcmV0dXJuIEdGLnRhYmxlcy5leHBbKEdGLnRhYmxlcy5sb2dbeF0gKyBHRi50YWJsZXMubG9nW3ldKSAlIDI1NV07XG4gICAgfSxcbiAgICBhZGQ6ICh4LCB5KSA9PiB4IF4geSxcbiAgICBwb3c6ICh4LCBlKSA9PiBHRi50YWJsZXMuZXhwWyhHRi50YWJsZXMubG9nW3hdICogZSkgJSAyNTVdLFxuICAgIGludih4KSB7XG4gICAgICAgIGlmICh4ID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBHRi5pbnZlcnNlOiBpbnZhbGlkIGFyZz0ke3h9YCk7XG4gICAgICAgIHJldHVybiBHRi50YWJsZXMuZXhwWzI1NSAtIEdGLnRhYmxlcy5sb2dbeF1dO1xuICAgIH0sXG4gICAgcG9seW5vbWlhbChwb2x5KSB7XG4gICAgICAgIGlmIChwb2x5Lmxlbmd0aCA9PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdHRi5wb2x5bW9taWFsOiBpbnZhbGlkIGxlbmd0aCcpO1xuICAgICAgICBpZiAocG9seVswXSAhPT0gMClcbiAgICAgICAgICAgIHJldHVybiBwb2x5O1xuICAgICAgICAvLyBTdHJpcCBsZWFkaW5nIHplcm9zXG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBwb2x5Lmxlbmd0aCAtIDEgJiYgcG9seVtpXSA9PSAwOyBpKyspXG4gICAgICAgICAgICA7XG4gICAgICAgIHJldHVybiBwb2x5LnNsaWNlKGkpO1xuICAgIH0sXG4gICAgbW9ub21pYWwoZGVncmVlLCBjb2VmZmljaWVudCkge1xuICAgICAgICBpZiAoZGVncmVlIDwgMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR0YubW9ub21pYWw6IGludmFsaWQgZGVncmVlPSR7ZGVncmVlfWApO1xuICAgICAgICBpZiAoY29lZmZpY2llbnQgPT0gMClcbiAgICAgICAgICAgIHJldHVybiBbMF07XG4gICAgICAgIGxldCBjb2VmZmljaWVudHMgPSBmaWxsQXJyKGRlZ3JlZSArIDEsIDApO1xuICAgICAgICBjb2VmZmljaWVudHNbMF0gPSBjb2VmZmljaWVudDtcbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwoY29lZmZpY2llbnRzKTtcbiAgICB9LFxuICAgIGRlZ3JlZTogKGEpID0+IGEubGVuZ3RoIC0gMSxcbiAgICBjb2VmZmljaWVudDogKGEsIGRlZ3JlZSkgPT4gYVtHRi5kZWdyZWUoYSkgLSBkZWdyZWVdLFxuICAgIG11bFBvbHkoYSwgYikge1xuICAgICAgICBpZiAoYVswXSA9PT0gMCB8fCBiWzBdID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIFswXTtcbiAgICAgICAgY29uc3QgcmVzID0gZmlsbEFycihhLmxlbmd0aCArIGIubGVuZ3RoIC0gMSwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBiLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgcmVzW2kgKyBqXSA9IEdGLmFkZChyZXNbaSArIGpdLCBHRi5tdWwoYVtpXSwgYltqXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBHRi5wb2x5bm9taWFsKHJlcyk7XG4gICAgfSxcbiAgICBtdWxQb2x5U2NhbGFyKGEsIHNjYWxhcikge1xuICAgICAgICBpZiAoc2NhbGFyID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICBpZiAoc2NhbGFyID09IDEpXG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgY29uc3QgcmVzID0gZmlsbEFycihhLmxlbmd0aCwgMCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlc1tpXSA9IEdGLm11bChhW2ldLCBzY2FsYXIpO1xuICAgICAgICByZXR1cm4gR0YucG9seW5vbWlhbChyZXMpO1xuICAgIH0sXG4gICAgbXVsUG9seU1vbm9taWFsKGEsIGRlZ3JlZSwgY29lZmZpY2llbnQpIHtcbiAgICAgICAgaWYgKGRlZ3JlZSA8IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dGLm11bFBvbHlNb25vbWlhbDogaW52YWxpZCBkZWdyZWUnKTtcbiAgICAgICAgaWYgKGNvZWZmaWNpZW50ID09IDApXG4gICAgICAgICAgICByZXR1cm4gWzBdO1xuICAgICAgICBjb25zdCByZXMgPSBmaWxsQXJyKGEubGVuZ3RoICsgZGVncmVlLCAwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcmVzW2ldID0gR0YubXVsKGFbaV0sIGNvZWZmaWNpZW50KTtcbiAgICAgICAgcmV0dXJuIEdGLnBvbHlub21pYWwocmVzKTtcbiAgICB9LFxuICAgIGFkZFBvbHkoYSwgYikge1xuICAgICAgICBpZiAoYVswXSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICBpZiAoYlswXSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICBsZXQgc21hbGxlciA9IGE7XG4gICAgICAgIGxldCBsYXJnZXIgPSBiO1xuICAgICAgICBpZiAoc21hbGxlci5sZW5ndGggPiBsYXJnZXIubGVuZ3RoKVxuICAgICAgICAgICAgW3NtYWxsZXIsIGxhcmdlcl0gPSBbbGFyZ2VyLCBzbWFsbGVyXTtcbiAgICAgICAgbGV0IHN1bURpZmYgPSBmaWxsQXJyKGxhcmdlci5sZW5ndGgsIDApO1xuICAgICAgICBsZXQgbGVuZ3RoRGlmZiA9IGxhcmdlci5sZW5ndGggLSBzbWFsbGVyLmxlbmd0aDtcbiAgICAgICAgbGV0IHMgPSBsYXJnZXIuc2xpY2UoMCwgbGVuZ3RoRGlmZik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHN1bURpZmZbaV0gPSBzW2ldO1xuICAgICAgICBmb3IgKGxldCBpID0gbGVuZ3RoRGlmZjsgaSA8IGxhcmdlci5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHN1bURpZmZbaV0gPSBHRi5hZGQoc21hbGxlcltpIC0gbGVuZ3RoRGlmZl0sIGxhcmdlcltpXSk7XG4gICAgICAgIHJldHVybiBHRi5wb2x5bm9taWFsKHN1bURpZmYpO1xuICAgIH0sXG4gICAgcmVtYWluZGVyUG9seShkYXRhLCBkaXZpc29yKSB7XG4gICAgICAgIGNvbnN0IG91dCA9IEFycmF5LmZyb20oZGF0YSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGggLSBkaXZpc29yLmxlbmd0aCArIDE7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgZWxtID0gb3V0W2ldO1xuICAgICAgICAgICAgaWYgKGVsbSA9PT0gMClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAxOyBqIDwgZGl2aXNvci5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGlmIChkaXZpc29yW2pdICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBvdXRbaSArIGpdID0gR0YuYWRkKG91dFtpICsgal0sIEdGLm11bChkaXZpc29yW2pdLCBlbG0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0LnNsaWNlKGRhdGEubGVuZ3RoIC0gZGl2aXNvci5sZW5ndGggKyAxLCBvdXQubGVuZ3RoKTtcbiAgICB9LFxuICAgIGRpdmlzb3JQb2x5KGRlZ3JlZSkge1xuICAgICAgICBsZXQgZyA9IFsxXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkZWdyZWU7IGkrKylcbiAgICAgICAgICAgIGcgPSBHRi5tdWxQb2x5KGcsIFsxLCBHRi5wb3coMiwgaSldKTtcbiAgICAgICAgcmV0dXJuIGc7XG4gICAgfSxcbiAgICBldmFsUG9seShwb2x5LCBhKSB7XG4gICAgICAgIGlmIChhID09IDApXG4gICAgICAgICAgICByZXR1cm4gR0YuY29lZmZpY2llbnQocG9seSwgMCk7IC8vIEp1c3QgcmV0dXJuIHRoZSB4XjAgY29lZmZpY2llbnRcbiAgICAgICAgbGV0IHJlcyA9IHBvbHlbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcG9seS5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHJlcyA9IEdGLmFkZChHRi5tdWwoYSwgcmVzKSwgcG9seVtpXSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfSxcbiAgICAvLyBUT0RPOiBjbGVhbnVwXG4gICAgZXVjbGlkaWFuKGEsIGIsIFIpIHtcbiAgICAgICAgLy8gRm9yY2UgZGVncmVlKGEpID49IGRlZ3JlZShiKVxuICAgICAgICBpZiAoR0YuZGVncmVlKGEpIDwgR0YuZGVncmVlKGIpKVxuICAgICAgICAgICAgW2EsIGJdID0gW2IsIGFdO1xuICAgICAgICBsZXQgckxhc3QgPSBhO1xuICAgICAgICBsZXQgciA9IGI7XG4gICAgICAgIGxldCB0TGFzdCA9IFswXTtcbiAgICAgICAgbGV0IHQgPSBbMV07XG4gICAgICAgIC8vIHdoaWxlIGRlZ3JlZSBvZiBSaSDiiaUgdC8yXG4gICAgICAgIHdoaWxlICgyICogR0YuZGVncmVlKHIpID49IFIpIHtcbiAgICAgICAgICAgIGxldCByTGFzdExhc3QgPSByTGFzdDtcbiAgICAgICAgICAgIGxldCB0TGFzdExhc3QgPSB0TGFzdDtcbiAgICAgICAgICAgIHJMYXN0ID0gcjtcbiAgICAgICAgICAgIHRMYXN0ID0gdDtcbiAgICAgICAgICAgIGlmIChyTGFzdFswXSA9PT0gMClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JMYXN0WzBdID09PSAwJyk7XG4gICAgICAgICAgICByID0gckxhc3RMYXN0O1xuICAgICAgICAgICAgbGV0IHEgPSBbMF07XG4gICAgICAgICAgICBjb25zdCBkbHRJbnZlcnNlID0gR0YuaW52KHJMYXN0WzBdKTtcbiAgICAgICAgICAgIHdoaWxlIChHRi5kZWdyZWUocikgPj0gR0YuZGVncmVlKHJMYXN0KSAmJiByWzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVncmVlRGlmZiA9IEdGLmRlZ3JlZShyKSAtIEdGLmRlZ3JlZShyTGFzdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2NhbGUgPSBHRi5tdWwoclswXSwgZGx0SW52ZXJzZSk7XG4gICAgICAgICAgICAgICAgcSA9IEdGLmFkZFBvbHkocSwgR0YubW9ub21pYWwoZGVncmVlRGlmZiwgc2NhbGUpKTtcbiAgICAgICAgICAgICAgICByID0gR0YuYWRkUG9seShyLCBHRi5tdWxQb2x5TW9ub21pYWwockxhc3QsIGRlZ3JlZURpZmYsIHNjYWxlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBxID0gR0YubXVsUG9seShxLCB0TGFzdCk7XG4gICAgICAgICAgICB0ID0gR0YuYWRkUG9seShxLCB0TGFzdExhc3QpO1xuICAgICAgICAgICAgaWYgKEdGLmRlZ3JlZShyKSA+PSBHRi5kZWdyZWUockxhc3QpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRGl2aXNpb24gZmFpbGVkIHI6ICR7cn0sIHJMYXN0OiAke3JMYXN0fWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ21hVGlsZGVBdFplcm8gPSBHRi5jb2VmZmljaWVudCh0LCAwKTtcbiAgICAgICAgaWYgKHNpZ21hVGlsZGVBdFplcm8gPT0gMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2lnbWFUaWxkZSgwKSB3YXMgemVybycpO1xuICAgICAgICBjb25zdCBpbnZlcnNlID0gR0YuaW52KHNpZ21hVGlsZGVBdFplcm8pO1xuICAgICAgICByZXR1cm4gW0dGLm11bFBvbHlTY2FsYXIodCwgaW52ZXJzZSksIEdGLm11bFBvbHlTY2FsYXIociwgaW52ZXJzZSldO1xuICAgIH0sXG59O1xuZnVuY3Rpb24gUlMoZWNjV29yZHMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBlbmNvZGUoZnJvbSkge1xuICAgICAgICAgICAgY29uc3QgZCA9IEdGLmRpdmlzb3JQb2x5KGVjY1dvcmRzKTtcbiAgICAgICAgICAgIGNvbnN0IHBvbCA9IEFycmF5LmZyb20oZnJvbSk7XG4gICAgICAgICAgICBwb2wucHVzaCguLi5kLnNsaWNlKDAsIC0xKS5maWxsKDApKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20oR0YucmVtYWluZGVyUG9seShwb2wsIGQpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlKHRvKSB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSB0by5zbGljZSgpO1xuICAgICAgICAgICAgY29uc3QgcG9seSA9IEdGLnBvbHlub21pYWwoQXJyYXkuZnJvbSh0bykpO1xuICAgICAgICAgICAgLy8gRmluZCBlcnJvcnNcbiAgICAgICAgICAgIGxldCBzeW5kcm9tZSA9IGZpbGxBcnIoZWNjV29yZHMsIDApO1xuICAgICAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVjY1dvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBldmwgPSBHRi5ldmFsUG9seShwb2x5LCBHRi5leHAoaSkpO1xuICAgICAgICAgICAgICAgIHN5bmRyb21lW3N5bmRyb21lLmxlbmd0aCAtIDEgLSBpXSA9IGV2bDtcbiAgICAgICAgICAgICAgICBpZiAoZXZsICE9PSAwKVxuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWhhc0Vycm9yKVxuICAgICAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgICBzeW5kcm9tZSA9IEdGLnBvbHlub21pYWwoc3luZHJvbWUpO1xuICAgICAgICAgICAgY29uc3QgbW9ub21pYWwgPSBHRi5tb25vbWlhbChlY2NXb3JkcywgMSk7XG4gICAgICAgICAgICBjb25zdCBbZXJyb3JMb2NhdG9yLCBlcnJvckV2YWx1YXRvcl0gPSBHRi5ldWNsaWRpYW4obW9ub21pYWwsIHN5bmRyb21lLCBlY2NXb3Jkcyk7XG4gICAgICAgICAgICAvLyBFcnJvciBsb2NhdGlvbnNcbiAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9ucyA9IGZpbGxBcnIoR0YuZGVncmVlKGVycm9yTG9jYXRvciksIDApO1xuICAgICAgICAgICAgbGV0IGUgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCAyNTYgJiYgZSA8IGxvY2F0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChHRi5ldmFsUG9seShlcnJvckxvY2F0b3IsIGkpID09PSAwKVxuICAgICAgICAgICAgICAgICAgICBsb2NhdGlvbnNbZSsrXSA9IEdGLmludihpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlICE9PSBsb2NhdGlvbnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlMuZGVjb2RlOiBpbnZhbGlkIGVycm9ycyBudW1iZXInKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9jYXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcG9zID0gcmVzLmxlbmd0aCAtIDEgLSBHRi5sb2cobG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBpZiAocG9zIDwgMClcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSUy5kZWNvZGU6IGludmFsaWQgZXJyb3IgbG9jYXRpb24nKTtcbiAgICAgICAgICAgICAgICBjb25zdCB4aUludmVyc2UgPSBHRi5pbnYobG9jYXRpb25zW2ldKTtcbiAgICAgICAgICAgICAgICBsZXQgZGVub21pbmF0b3IgPSAxO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbG9jYXRpb25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID09PSBqKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbm9taW5hdG9yID0gR0YubXVsKGRlbm9taW5hdG9yLCBHRi5hZGQoMSwgR0YubXVsKGxvY2F0aW9uc1tqXSwgeGlJbnZlcnNlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNbcG9zXSA9IEdGLmFkZChyZXNbcG9zXSwgR0YubXVsKEdGLmV2YWxQb2x5KGVycm9yRXZhbHVhdG9yLCB4aUludmVyc2UpLCBHRi5pbnYoZGVub21pbmF0b3IpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB9LFxuICAgIH07XG59XG4vLyBJbnRlcmxlYXZlcyBibG9ja3NcbmZ1bmN0aW9uIGludGVybGVhdmUodmVyLCBlY2MpIHtcbiAgICBjb25zdCB7IHdvcmRzLCBzaG9ydEJsb2NrcywgbnVtQmxvY2tzLCBibG9ja0xlbiwgdG90YWwgfSA9IGluZm8uY2FwYWNpdHkodmVyLCBlY2MpO1xuICAgIGNvbnN0IHJzID0gUlMod29yZHMpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZShieXRlcykge1xuICAgICAgICAgICAgLy8gQWRkIGVycm9yIGNvcnJlY3Rpb24gdG8gYnl0ZXNcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgZWNjQmxvY2tzID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUJsb2NrczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNTaG9ydCA9IGkgPCBzaG9ydEJsb2NrcztcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBibG9ja0xlbiArIChpc1Nob3J0ID8gMCA6IDEpO1xuICAgICAgICAgICAgICAgIGJsb2Nrcy5wdXNoKGJ5dGVzLnN1YmFycmF5KDAsIGxlbikpO1xuICAgICAgICAgICAgICAgIGVjY0Jsb2Nrcy5wdXNoKHJzLmVuY29kZShieXRlcy5zdWJhcnJheSgwLCBsZW4pKSk7XG4gICAgICAgICAgICAgICAgYnl0ZXMgPSBieXRlcy5zdWJhcnJheShsZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVzQmxvY2tzID0gaW50ZXJsZWF2ZUJ5dGVzKGJsb2Nrcyk7XG4gICAgICAgICAgICBjb25zdCByZXNFQ0MgPSBpbnRlcmxlYXZlQnl0ZXMoZWNjQmxvY2tzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHJlc0Jsb2Nrcy5sZW5ndGggKyByZXNFQ0MubGVuZ3RoKTtcbiAgICAgICAgICAgIHJlcy5zZXQocmVzQmxvY2tzKTtcbiAgICAgICAgICAgIHJlcy5zZXQocmVzRUNDLCByZXNCbG9ja3MubGVuZ3RoKTtcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlY29kZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT09IHRvdGFsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW50ZXJsZWF2ZS5kZWNvZGU6IGxlbihkYXRhKT0ke2RhdGEubGVuZ3RofSwgdG90YWw9JHt0b3RhbH1gKTtcbiAgICAgICAgICAgIGNvbnN0IGJsb2NrcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1CbG9ja3M7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzU2hvcnQgPSBpIDwgc2hvcnRCbG9ja3M7XG4gICAgICAgICAgICAgICAgYmxvY2tzLnB1c2gobmV3IFVpbnQ4QXJyYXkod29yZHMgKyBibG9ja0xlbiArIChpc1Nob3J0ID8gMCA6IDEpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaG9ydCBibG9ja3NcbiAgICAgICAgICAgIGxldCBwb3MgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBudW1CbG9ja3M7IGorKylcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tzW2pdW2ldID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMb25nIGJsb2Nrc1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IHNob3J0QmxvY2tzOyBqIDwgbnVtQmxvY2tzOyBqKyspXG4gICAgICAgICAgICAgICAgYmxvY2tzW2pdW2Jsb2NrTGVuXSA9IGRhdGFbcG9zKytdO1xuICAgICAgICAgICAgLy8gRUNDXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYmxvY2tMZW47IGkgPCBibG9ja0xlbiArIHdvcmRzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG51bUJsb2NrczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzU2hvcnQgPSBqIDwgc2hvcnRCbG9ja3M7XG4gICAgICAgICAgICAgICAgICAgIGJsb2Nrc1tqXVtpICsgKGlzU2hvcnQgPyAwIDogMSldID0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRGVjb2RlXG4gICAgICAgICAgICAvLyBFcnJvci1jb3JyZWN0IGFuZCBjb3B5IGRhdGEgYmxvY2tzIHRvZ2V0aGVyIGludG8gYSBzdHJlYW0gb2YgYnl0ZXNcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBibG9jayBvZiBibG9ja3MpXG4gICAgICAgICAgICAgICAgcmVzLnB1c2goLi4uQXJyYXkuZnJvbShycy5kZWNvZGUoYmxvY2spKS5zbGljZSgwLCAtd29yZHMpKTtcbiAgICAgICAgICAgIHJldHVybiBVaW50OEFycmF5LmZyb20ocmVzKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8gRHJhd1xuLy8gR2VuZXJpYyB0ZW1wbGF0ZSBwZXIgdmVyc2lvbitlY2MrbWFzay4gQ2FuIGJlIGNhY2hlZCwgdG8gc3BlZWR1cCBjYWxjdWxhdGlvbnMuXG5mdW5jdGlvbiBkcmF3VGVtcGxhdGUodmVyLCBlY2MsIG1hc2tJZHgsIHRlc3QgPSBmYWxzZSkge1xuICAgIGNvbnN0IHNpemUgPSBpbmZvLnNpemUuZW5jb2RlKHZlcik7XG4gICAgbGV0IGIgPSBuZXcgQml0bWFwKHNpemUgKyAyKTtcbiAgICAvLyBGaW5kZXIgcGF0dGVybnNcbiAgICAvLyBXZSBkcmF3IGZ1bGwgcGF0dGVybiBhbmQgbGF0ZXIgc2xpY2UsIHNpbmNlIGJlZm9yZSBhZGRpdGlvbiBvZiBib3JkZXJzIGZpbmRlciBpcyB0cnVuY2F0ZWQgYnkgb25lIHBpeGVsIG9uIHNpZGVzXG4gICAgY29uc3QgZmluZGVyID0gbmV3IEJpdG1hcCgzKS5yZWN0KDAsIDMsIHRydWUpLmJvcmRlcigxLCBmYWxzZSkuYm9yZGVyKDEsIHRydWUpLmJvcmRlcigxLCBmYWxzZSk7XG4gICAgYiA9IGJcbiAgICAgICAgLmVtYmVkKDAsIGZpbmRlcikgLy8gdG9wIGxlZnRcbiAgICAgICAgLmVtYmVkKHsgeDogLWZpbmRlci53aWR0aCwgeTogMCB9LCBmaW5kZXIpIC8vIHRvcCByaWdodFxuICAgICAgICAuZW1iZWQoeyB4OiAwLCB5OiAtZmluZGVyLmhlaWdodCB9LCBmaW5kZXIpOyAvLyBib3R0b20gbGVmdFxuICAgIGIgPSBiLnJlY3RTbGljZSgxLCBzaXplKTtcbiAgICAvLyBBbGlnbm1lbnQgcGF0dGVybnNcbiAgICBjb25zdCBhbGlnbiA9IG5ldyBCaXRtYXAoMSkucmVjdCgwLCAxLCB0cnVlKS5ib3JkZXIoMSwgZmFsc2UpLmJvcmRlcigxLCB0cnVlKTtcbiAgICBjb25zdCBhbGlnblBvcyA9IGluZm8uYWxpZ25tZW50UGF0dGVybnModmVyKTtcbiAgICBmb3IgKGNvbnN0IHkgb2YgYWxpZ25Qb3MpIHtcbiAgICAgICAgZm9yIChjb25zdCB4IG9mIGFsaWduUG9zKSB7XG4gICAgICAgICAgICBpZiAoYi5pc0RlZmluZWQoeCwgeSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBiLmVtYmVkKHsgeDogeCAtIDIsIHk6IHkgLSAyIH0sIGFsaWduKTsgLy8gY2VudGVyIG9mIHBhdHRlcm4gc2hvdWxkIGJlIGF0IHBvc2l0aW9uXG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGltaW5nIHBhdHRlcm5zXG4gICAgYiA9IGJcbiAgICAgICAgLmhMaW5lKHsgeDogMCwgeTogNiB9LCBJbmZpbml0eSwgKHsgeCB9KSA9PiAoYi5pc0RlZmluZWQoeCwgNikgPyB1bmRlZmluZWQgOiB4ICUgMiA9PSAwKSlcbiAgICAgICAgLnZMaW5lKHsgeDogNiwgeTogMCB9LCBJbmZpbml0eSwgKHsgeSB9KSA9PiAoYi5pc0RlZmluZWQoNiwgeSkgPyB1bmRlZmluZWQgOiB5ICUgMiA9PSAwKSk7XG4gICAgLy8gRm9ybWF0IGluZm9ybWF0aW9uXG4gICAge1xuICAgICAgICBjb25zdCBiaXRzID0gaW5mby5mb3JtYXRCaXRzKGVjYywgbWFza0lkeCk7XG4gICAgICAgIGNvbnN0IGdldEJpdCA9IChpKSA9PiAhdGVzdCAmJiAoKGJpdHMgPj4gaSkgJiAxKSA9PSAxO1xuICAgICAgICAvLyB2ZXJ0aWNhbFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7IGkrKylcbiAgICAgICAgICAgIGIuc2V0KDgsIGksIGdldEJpdChpKSk7IC8vIHJpZ2h0IG9mIHRvcC1sZWZ0IGZpbmRlclxuICAgICAgICAvLyBUT0RPOiByZS13cml0ZSBhcyBsaW5lcywgbGlrZTpcbiAgICAgICAgLy8gYi52TGluZSh7IHg6IDgsIHk6IDAgfSwgNiwgKHsgeCwgeSB9KSA9PiBnZXRCaXQoeSkpO1xuICAgICAgICBmb3IgKGxldCBpID0gNjsgaSA8IDg7IGkrKylcbiAgICAgICAgICAgIGIuc2V0KDgsIGkgKyAxLCBnZXRCaXQoaSkpOyAvLyBhZnRlciB0aW1pbmcgcGF0dGVyblxuICAgICAgICBmb3IgKGxldCBpID0gODsgaSA8IDE1OyBpKyspXG4gICAgICAgICAgICBiLnNldCg4LCBzaXplIC0gMTUgKyBpLCBnZXRCaXQoaSkpOyAvLyByaWdodCBvZiBib3R0b20tbGVmdCBmaW5kZXJcbiAgICAgICAgLy8gaG9yaXpvbnRhbFxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKylcbiAgICAgICAgICAgIGIuc2V0KHNpemUgLSBpIC0gMSwgOCwgZ2V0Qml0KGkpKTsgLy8gdW5kZXIgdG9wLXJpZ2h0IGZpbmRlclxuICAgICAgICBmb3IgKGxldCBpID0gODsgaSA8IDk7IGkrKylcbiAgICAgICAgICAgIGIuc2V0KDE1IC0gaSAtIDEgKyAxLCA4LCBnZXRCaXQoaSkpOyAvLyBWVlYsIGFmdGVyIHRpbWluZ1xuICAgICAgICBmb3IgKGxldCBpID0gOTsgaSA8IDE1OyBpKyspXG4gICAgICAgICAgICBiLnNldCgxNSAtIGkgLSAxLCA4LCBnZXRCaXQoaSkpOyAvLyB1bmRlciB0b3AtbGVmdCBmaW5kZXJcbiAgICAgICAgYi5zZXQoOCwgc2l6ZSAtIDgsICF0ZXN0KTsgLy8gYm90dG9tLWxlZnQgZmluZGVyLCByaWdodFxuICAgIH1cbiAgICAvLyBWZXJzaW9uIGluZm9ybWF0aW9uXG4gICAgaWYgKHZlciA+PSA3KSB7XG4gICAgICAgIGNvbnN0IGJpdHMgPSBpbmZvLnZlcnNpb25CaXRzKHZlcik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTg7IGkgKz0gMSkge1xuICAgICAgICAgICAgY29uc3QgYml0ID0gIXRlc3QgJiYgKChiaXRzID4+IGkpICYgMSkgPT0gMTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBNYXRoLmZsb29yKGkgLyAzKTtcbiAgICAgICAgICAgIGNvbnN0IHkgPSAoaSAlIDMpICsgc2l6ZSAtIDggLSAzO1xuICAgICAgICAgICAgLy8gdHdvIGNvcGllc1xuICAgICAgICAgICAgYi5zZXQoeSwgeCwgYml0KTtcbiAgICAgICAgICAgIGIuc2V0KHgsIHksIGJpdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGI7XG59XG4vLyB6aWd6YWc6IGJvdHRvbS0+dG9wICYmIHRvcC0+Ym90dG9tXG5mdW5jdGlvbiB6aWd6YWcodHBsLCBtYXNrSWR4LCBmbikge1xuICAgIGNvbnN0IHNpemUgPSB0cGwuaGVpZ2h0O1xuICAgIGNvbnN0IHBhdHRlcm4gPSBQQVRURVJOU1ttYXNrSWR4XTtcbiAgICAvLyB6aWctemFnIHBhdHRlcm5cbiAgICBsZXQgZGlyID0gLTE7XG4gICAgbGV0IHkgPSBzaXplIC0gMTtcbiAgICAvLyB0d28gY29sdW1ucyBhdCB0aW1lXG4gICAgZm9yIChsZXQgeE9mZnNldCA9IHNpemUgLSAxOyB4T2Zmc2V0ID4gMDsgeE9mZnNldCAtPSAyKSB7XG4gICAgICAgIGlmICh4T2Zmc2V0ID09IDYpXG4gICAgICAgICAgICB4T2Zmc2V0ID0gNTsgLy8gc2tpcCB2ZXJ0aWNhbCB0aW1pbmcgcGF0dGVyblxuICAgICAgICBmb3IgKDs7IHkgKz0gZGlyKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IDI7IGogKz0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSB4T2Zmc2V0IC0gajtcbiAgICAgICAgICAgICAgICBpZiAodHBsLmlzRGVmaW5lZCh4LCB5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHNraXAgYWxyZWFkeSB3cml0dGVuIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgZm4oeCwgeSwgcGF0dGVybih4LCB5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeSArIGRpciA8IDAgfHwgeSArIGRpciA+PSBzaXplKVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGRpciA9IC1kaXI7IC8vIGNoYW5nZSBkaXJlY3Rpb25cbiAgICB9XG59XG4vLyBOT1RFOiBieXRlIGVuY29kaW5nIGlzIGp1c3QgcmVwcmVzZW50YXRpb24sIFFSIHdvcmtzIHdpdGggc3RyaW5ncyBvbmx5LiBNb3N0IGRlY29kZXJzIHdpbGwgZmFpbCBvbiByYXcgYnl0ZSBhcnJheSxcbi8vIHNpbmNlIHRoZXkgZXhwZWN0IHVuaWNvZGUgb3Igb3RoZXIgdGV4dCBlbmNvZGluZyBpbnNpZGUgYnl0ZXNcbmZ1bmN0aW9uIGRldGVjdFR5cGUoc3RyKSB7XG4gICAgbGV0IHR5cGUgPSAnbnVtZXJpYyc7XG4gICAgZm9yIChsZXQgeCBvZiBzdHIpIHtcbiAgICAgICAgaWYgKGluZm8uYWxwaGFiZXQubnVtZXJpYy5oYXMoeCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgdHlwZSA9ICdhbHBoYW51bWVyaWMnO1xuICAgICAgICBpZiAoIWluZm8uYWxwaGFiZXQuYWxwaGFudW1lcmMuaGFzKHgpKVxuICAgICAgICAgICAgcmV0dXJuICdieXRlJztcbiAgICB9XG4gICAgcmV0dXJuIHR5cGU7XG59XG4vKipcbiAqIEBleGFtcGxlIHV0ZjhUb0J5dGVzKCdhYmMnKSAvLyBuZXcgVWludDhBcnJheShbOTcsIDk4LCA5OV0pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1dGY4VG9CeXRlcyhzdHIpIHtcbiAgICBpZiAodHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgdXRmOFRvQnl0ZXMgZXhwZWN0ZWQgc3RyaW5nLCBnb3QgJHt0eXBlb2Ygc3RyfWApO1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSk7IC8vIGh0dHBzOi8vYnVnemlsLmxhLzE2ODE4MDlcbn1cbmZ1bmN0aW9uIGVuY29kZSh2ZXIsIGVjYywgZGF0YSwgdHlwZSwgZW5jb2RlciA9IHV0ZjhUb0J5dGVzKSB7XG4gICAgbGV0IGVuY29kZWQgPSAnJztcbiAgICBsZXQgZGF0YUxlbiA9IGRhdGEubGVuZ3RoO1xuICAgIGlmICh0eXBlID09PSAnbnVtZXJpYycpIHtcbiAgICAgICAgY29uc3QgdCA9IGluZm8uYWxwaGFiZXQubnVtZXJpYy5kZWNvZGUoZGF0YS5zcGxpdCgnJykpO1xuICAgICAgICBjb25zdCBuID0gdC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbiAtIDI7IGkgKz0gMylcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbaV0gKiAxMDAgKyB0W2kgKyAxXSAqIDEwICsgdFtpICsgMl0sIDEwKTtcbiAgICAgICAgaWYgKG4gJSAzID09PSAxKSB7XG4gICAgICAgICAgICBlbmNvZGVkICs9IGJpbih0W24gLSAxXSwgNCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiAlIDMgPT09IDIpIHtcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbbiAtIDJdICogMTAgKyB0W24gLSAxXSwgNyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2FscGhhbnVtZXJpYycpIHtcbiAgICAgICAgY29uc3QgdCA9IGluZm8uYWxwaGFiZXQuYWxwaGFudW1lcmMuZGVjb2RlKGRhdGEuc3BsaXQoJycpKTtcbiAgICAgICAgY29uc3QgbiA9IHQubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG4gLSAxOyBpICs9IDIpXG4gICAgICAgICAgICBlbmNvZGVkICs9IGJpbih0W2ldICogNDUgKyB0W2kgKyAxXSwgMTEpO1xuICAgICAgICBpZiAobiAlIDIgPT0gMSlcbiAgICAgICAgICAgIGVuY29kZWQgKz0gYmluKHRbbiAtIDFdLCA2KTsgLy8gcGFkIGlmIG9kZCBudW1iZXIgb2YgY2hhcnNcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZSA9PT0gJ2J5dGUnKSB7XG4gICAgICAgIGNvbnN0IHV0ZjggPSBlbmNvZGVyKGRhdGEpO1xuICAgICAgICBkYXRhTGVuID0gdXRmOC5sZW5ndGg7XG4gICAgICAgIGVuY29kZWQgPSBBcnJheS5mcm9tKHV0ZjgpXG4gICAgICAgICAgICAubWFwKChpKSA9PiBiaW4oaSwgOCkpXG4gICAgICAgICAgICAuam9pbignJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2VuY29kZTogdW5zdXBwb3J0ZWQgdHlwZScpO1xuICAgIH1cbiAgICBjb25zdCB7IGNhcGFjaXR5IH0gPSBpbmZvLmNhcGFjaXR5KHZlciwgZWNjKTtcbiAgICBjb25zdCBsZW4gPSBiaW4oZGF0YUxlbiwgaW5mby5sZW5ndGhCaXRzKHZlciwgdHlwZSkpO1xuICAgIGxldCBiaXRzID0gaW5mby5tb2RlQml0c1t0eXBlXSArIGxlbiArIGVuY29kZWQ7XG4gICAgaWYgKGJpdHMubGVuZ3RoID4gY2FwYWNpdHkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2FwYWNpdHkgb3ZlcmZsb3cnKTtcbiAgICAvLyBUZXJtaW5hdG9yXG4gICAgYml0cyArPSAnMCcucmVwZWF0KE1hdGgubWluKDQsIE1hdGgubWF4KDAsIGNhcGFjaXR5IC0gYml0cy5sZW5ndGgpKSk7XG4gICAgLy8gUGFkIGJpdHMgc3RyaW5nIHVudGlsbCBmdWxsIGJ5dGVcbiAgICBpZiAoYml0cy5sZW5ndGggJSA4KVxuICAgICAgICBiaXRzICs9ICcwJy5yZXBlYXQoOCAtIChiaXRzLmxlbmd0aCAlIDgpKTtcbiAgICAvLyBBZGQgcGFkZGluZyB1bnRpbCBjYXBhY2l0eSBpcyBmdWxsXG4gICAgY29uc3QgcGFkZGluZyA9ICcxMTEwMTEwMDAwMDEwMDAxJztcbiAgICBmb3IgKGxldCBpZHggPSAwOyBiaXRzLmxlbmd0aCAhPT0gY2FwYWNpdHk7IGlkeCsrKVxuICAgICAgICBiaXRzICs9IHBhZGRpbmdbaWR4ICUgcGFkZGluZy5sZW5ndGhdO1xuICAgIC8vIENvbnZlcnQgYSBiaXRzdHJpbmcgdG8gYXJyYXkgb2YgYnl0ZXNcbiAgICBjb25zdCBieXRlcyA9IFVpbnQ4QXJyYXkuZnJvbShiaXRzLm1hdGNoKC8oLns4fSkvZykubWFwKChpKSA9PiBOdW1iZXIoYDBiJHtpfWApKSk7XG4gICAgcmV0dXJuIGludGVybGVhdmUodmVyLCBlY2MpLmVuY29kZShieXRlcyk7XG59XG4vLyBEUkFXXG5mdW5jdGlvbiBkcmF3UVIodmVyLCBlY2MsIGRhdGEsIG1hc2tJZHgsIHRlc3QgPSBmYWxzZSkge1xuICAgIGNvbnN0IGIgPSBkcmF3VGVtcGxhdGUodmVyLCBlY2MsIG1hc2tJZHgsIHRlc3QpO1xuICAgIGxldCBpID0gMDtcbiAgICBjb25zdCBuZWVkID0gOCAqIGRhdGEubGVuZ3RoO1xuICAgIHppZ3phZyhiLCBtYXNrSWR4LCAoeCwgeSwgbWFzaykgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGkgPCBuZWVkKSB7XG4gICAgICAgICAgICB2YWx1ZSA9ICgoZGF0YVtpID4+PiAzXSA+PiAoKDcgLSBpKSAmIDcpKSAmIDEpICE9PSAwO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIGIuc2V0KHgsIHksIHZhbHVlICE9PSBtYXNrKTsgLy8gIT09IGFzIHhvclxuICAgIH0pO1xuICAgIGlmIChpICE9PSBuZWVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1FSOiBieXRlcyBsZWZ0IGFmdGVyIGRyYXcnKTtcbiAgICByZXR1cm4gYjtcbn1cbmNvbnN0IG1rUGF0dGVybiA9IChwYXR0ZXJuKSA9PiB7XG4gICAgY29uc3QgcyA9IHBhdHRlcm4ubWFwKChpKSA9PiAoaSA/ICcxJyA6ICcwJykpLmpvaW4oJycpO1xuICAgIHJldHVybiB7IGxlbjogcy5sZW5ndGgsIG46IE51bWJlcihgMGIke3N9YCkgfTtcbn07XG4vLyAxOjE6MzoxOjEgcmF0aW8gKGRhcms6bGlnaHQ6ZGFyazpsaWdodDpkYXJrKSBwYXR0ZXJuIGluIHJvdy9jb2x1bW4sIHByZWNlZGVkIG9yIGZvbGxvd2VkIGJ5IGxpZ2h0IGFyZWEgNCBtb2R1bGVzIHdpZGVcbmNvbnN0IGZpbmRlclBhdHRlcm4gPSBbdHJ1ZSwgZmFsc2UsIHRydWUsIHRydWUsIHRydWUsIGZhbHNlLCB0cnVlXTsgLy8gZGFyazpsaWdodDpkYXJrOmxpZ2h0OmRhcmtcbmNvbnN0IGxpZ2h0UGF0dGVybiA9IFtmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZV07IC8vIGxpZ2h0IGFyZWEgNCBtb2R1bGVzIHdpZGVcbmNvbnN0IFAxID0gbWtQYXR0ZXJuKFsuLi5maW5kZXJQYXR0ZXJuLCAuLi5saWdodFBhdHRlcm5dKTtcbmNvbnN0IFAyID0gbWtQYXR0ZXJuKFsuLi5saWdodFBhdHRlcm4sIC4uLmZpbmRlclBhdHRlcm5dKTtcbmZ1bmN0aW9uIHBlbmFsdHkoYm0pIHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGJtO1xuICAgIGNvbnN0IHRyYW5zcG9zZWQgPSBibS50cmFuc3Bvc2UoKTtcbiAgICAvLyBBZGphY2VudCBtb2R1bGVzIGluIHJvdy9jb2x1bW4gaW4gc2FtZSB8IE5vLiBvZiBtb2R1bGVzID0gKDUgKyBpKSBjb2xvclxuICAgIGxldCBhZGphY2VudCA9IDA7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICBibS5nZXRSdW5zKHksIChsZW4pID0+IHtcbiAgICAgICAgICAgIGlmIChsZW4gPj0gNSlcbiAgICAgICAgICAgICAgICBhZGphY2VudCArPSAzICsgKGxlbiAtIDUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB3aWR0aDsgeSsrKSB7XG4gICAgICAgIHRyYW5zcG9zZWQuZ2V0UnVucyh5LCAobGVuKSA9PiB7XG4gICAgICAgICAgICBpZiAobGVuID49IDUpXG4gICAgICAgICAgICAgICAgYWRqYWNlbnQgKz0gMyArIChsZW4gLSA1KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEJsb2NrIG9mIG1vZHVsZXMgaW4gc2FtZSBjb2xvciAoQmxvY2sgc2l6ZSA9IDJ4MilcbiAgICBsZXQgYm94ID0gMDtcbiAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodCAtIDE7IHkrKylcbiAgICAgICAgYm94ICs9IDMgKiBibS5jb3VudEJveGVzMngyKHkpO1xuICAgIGxldCBmaW5kZXIgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspXG4gICAgICAgIGZpbmRlciArPSA0MCAqIGJtLmNvdW50UGF0dGVybkluUm93KHksIFAxLmxlbiwgUDEubiwgUDIubik7XG4gICAgZm9yIChsZXQgeSA9IDA7IHkgPCB3aWR0aDsgeSsrKVxuICAgICAgICBmaW5kZXIgKz0gNDAgKiB0cmFuc3Bvc2VkLmNvdW50UGF0dGVybkluUm93KHksIFAxLmxlbiwgUDEubiwgUDIubik7XG4gICAgLy8gUHJvcG9ydGlvbiBvZiBkYXJrIG1vZHVsZXMgaW4gZW50aXJlIHN5bWJvbFxuICAgIC8vIEFkZCAxMCBwb2ludHMgdG8gYSBkZXZpYXRpb24gb2YgNSUgaW5jcmVtZW50IG9yIGRlY3JlbWVudCBpbiB0aGUgcHJvcG9ydGlvblxuICAgIC8vIHJhdGlvIG9mIGRhcmsgbW9kdWxlIGZyb20gdGhlIHJlZmVyZW50aWFsIDUwJVxuICAgIGxldCBkYXJrUGl4ZWxzID0gMDtcbiAgICBkYXJrUGl4ZWxzID0gYm0ucG9wY250KCk7XG4gICAgLy9ibS5yZWN0UmVhZCgwLCBJbmZpbml0eSwgKF9jLCB2YWwpID0+IChkYXJrUGl4ZWxzICs9IHZhbCA/IDEgOiAwKSk7XG4gICAgLy8gZm9yIChsZXQgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgIC8vICAgZm9yIChsZXQgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSBpZiAoYm0uZ2V0KHgsIHkpKSBkYXJrUGl4ZWxzKys7XG4gICAgLy8gfVxuICAgIGNvbnN0IGRhcmtQZXJjZW50ID0gKGRhcmtQaXhlbHMgLyAoaGVpZ2h0ICogd2lkdGgpKSAqIDEwMDtcbiAgICBjb25zdCBkYXJrID0gMTAgKiBNYXRoLmZsb29yKE1hdGguYWJzKGRhcmtQZXJjZW50IC0gNTApIC8gNSk7XG4gICAgcmV0dXJuIGFkamFjZW50ICsgYm94ICsgZmluZGVyICsgZGFyaztcbn1cbi8vIFNlbGVjdHMgYmVzdCBtYXNrIGFjY29yZGluZyB0byBwZW5hbHR5LCBpZiBubyBtYXNrIGlzIHByb3ZpZGVkXG5mdW5jdGlvbiBkcmF3UVJCZXN0KHZlciwgZWNjLCBkYXRhLCBtYXNrSWR4KSB7XG4gICAgaWYgKG1hc2tJZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBiZXN0TWFzayA9IGJlc3QoKTtcbiAgICAgICAgZm9yIChsZXQgbWFzayA9IDA7IG1hc2sgPCBQQVRURVJOUy5sZW5ndGg7IG1hc2srKylcbiAgICAgICAgICAgIGJlc3RNYXNrLmFkZChwZW5hbHR5KGRyYXdRUih2ZXIsIGVjYywgZGF0YSwgbWFzaywgdHJ1ZSkpLCBtYXNrKTtcbiAgICAgICAgbWFza0lkeCA9IGJlc3RNYXNrLmdldCgpO1xuICAgIH1cbiAgICBpZiAobWFza0lkeCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIG1hc2snKTsgLy8gU2hvdWxkIG5ldmVyIGhhcHBlblxuICAgIHJldHVybiBkcmF3UVIodmVyLCBlY2MsIGRhdGEsIG1hc2tJZHgpO1xufVxuZnVuY3Rpb24gdmFsaWRhdGVFQ0MoZWMpIHtcbiAgICBpZiAoIUVDTW9kZS5pbmNsdWRlcyhlYykpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlcnJvciBjb3JyZWN0aW9uIG1vZGU9JHtlY30uIEV4cGVjdGVkOiAke0VDTW9kZX1gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlRW5jb2RpbmcoZW5jKSB7XG4gICAgaWYgKCFFbmNvZGluZy5pbmNsdWRlcyhlbmMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuY29kaW5nOiBpbnZhbGlkIG1vZGU9JHtlbmN9LiBFeHBlY3RlZDogJHtFbmNvZGluZ31gKTtcbiAgICBpZiAoZW5jID09PSAna2FuamknIHx8IGVuYyA9PT0gJ2VjaScpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRW5jb2Rpbmc6ICR7ZW5jfSBpcyBub3Qgc3VwcG9ydGVkICh5ZXQ/KS5gKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlTWFzayhtYXNrKSB7XG4gICAgaWYgKCFbMCwgMSwgMiwgMywgNCwgNSwgNiwgN10uaW5jbHVkZXMobWFzaykgfHwgIVBBVFRFUk5TW21hc2tdKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgbWFzaz0ke21hc2t9LiBFeHBlY3RlZCBudW1iZXIgWzAuLjddYCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlUVIodGV4dCwgb3V0cHV0ID0gJ3JhdycsIG9wdHMgPSB7fSkge1xuICAgIGNvbnN0IGVjYyA9IG9wdHMuZWNjICE9PSB1bmRlZmluZWQgPyBvcHRzLmVjYyA6ICdtZWRpdW0nO1xuICAgIHZhbGlkYXRlRUNDKGVjYyk7XG4gICAgY29uc3QgZW5jb2RpbmcgPSBvcHRzLmVuY29kaW5nICE9PSB1bmRlZmluZWQgPyBvcHRzLmVuY29kaW5nIDogZGV0ZWN0VHlwZSh0ZXh0KTtcbiAgICB2YWxpZGF0ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgICBpZiAob3B0cy5tYXNrICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHZhbGlkYXRlTWFzayhvcHRzLm1hc2spO1xuICAgIGxldCB2ZXIgPSBvcHRzLnZlcnNpb247XG4gICAgbGV0IGRhdGEsIGVyciA9IG5ldyBFcnJvcignVW5rbm93biBlcnJvcicpO1xuICAgIGlmICh2ZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWxpZGF0ZVZlcnNpb24odmVyKTtcbiAgICAgICAgZGF0YSA9IGVuY29kZSh2ZXIsIGVjYywgdGV4dCwgZW5jb2RpbmcsIG9wdHMudGV4dEVuY29kZXIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gSWYgbm8gdmVyc2lvbiBpcyBwcm92aWRlZCwgdHJ5IHRvIGZpbmQgc21hbGxlc3Qgb25lIHdoaWNoIGZpdHNcbiAgICAgICAgLy8gQ3VycmVudGx5IGp1c3Qgc2NhbnMgYWxsIHZlcnNpb24sIGNhbiBiZSBzaWduaWZpY2FudGx5IHNwZWVkdXAgaWYgbmVlZGVkXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IDQwOyBpKyspIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGF0YSA9IGVuY29kZShpLCBlY2MsIHRleHQsIGVuY29kaW5nLCBvcHRzLnRleHRFbmNvZGVyKTtcbiAgICAgICAgICAgICAgICB2ZXIgPSBpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghdmVyIHx8ICFkYXRhKVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgbGV0IHJlcyA9IGRyYXdRUkJlc3QodmVyLCBlY2MsIGRhdGEsIG9wdHMubWFzayk7XG4gICAgcmVzLmFzc2VydERyYXduKCk7XG4gICAgY29uc3QgYm9yZGVyID0gb3B0cy5ib3JkZXIgPT09IHVuZGVmaW5lZCA/IDIgOiBvcHRzLmJvcmRlcjtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKGJvcmRlcikpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCBib3JkZXIgdHlwZT0ke3R5cGVvZiBib3JkZXJ9YCk7XG4gICAgcmVzID0gcmVzLmJvcmRlcihib3JkZXIsIGZhbHNlKTsgLy8gQWRkIGJvcmRlclxuICAgIGlmIChvcHRzLnNjYWxlICE9PSB1bmRlZmluZWQpXG4gICAgICAgIHJlcyA9IHJlcy5zY2FsZShvcHRzLnNjYWxlKTsgLy8gU2NhbGUgaW1hZ2VcbiAgICBpZiAob3V0cHV0ID09PSAncmF3JylcbiAgICAgICAgcmV0dXJuIHJlcy50b1JhdygpO1xuICAgIGVsc2UgaWYgKG91dHB1dCA9PT0gJ2FzY2lpJylcbiAgICAgICAgcmV0dXJuIHJlcy50b0FTQ0lJKCk7XG4gICAgZWxzZSBpZiAob3V0cHV0ID09PSAnc3ZnJylcbiAgICAgICAgcmV0dXJuIHJlcy50b1NWRyhvcHRzLm9wdGltaXplKTtcbiAgICBlbHNlIGlmIChvdXRwdXQgPT09ICdnaWYnKVxuICAgICAgICByZXR1cm4gcmVzLnRvR0lGKCk7XG4gICAgZWxzZSBpZiAob3V0cHV0ID09PSAndGVybScpXG4gICAgICAgIHJldHVybiByZXMudG9UZXJtKCk7XG4gICAgZWxzZVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gb3V0cHV0OiAke291dHB1dH1gKTtcbn1cbmV4cG9ydCBkZWZhdWx0IGVuY29kZVFSO1xuZXhwb3J0IGNvbnN0IHV0aWxzID0ge1xuICAgIGJlc3QsXG4gICAgYmluLFxuICAgIHBvcGNudCxcbiAgICBkcmF3VGVtcGxhdGUsXG4gICAgZmlsbEFycixcbiAgICBpbmZvLFxuICAgIGludGVybGVhdmUsXG4gICAgdmFsaWRhdGVWZXJzaW9uLFxuICAgIHppZ3phZyxcbn07XG4vLyBVbnNhZmUgQVBJIHV0aWxzLCBleHBvcnRlZCBvbmx5IGZvciB0ZXN0c1xuZXhwb3J0IGNvbnN0IF90ZXN0cyA9IHtcbiAgICBCaXRtYXAsXG4gICAgaW5mbyxcbiAgICBkZXRlY3RUeXBlLFxuICAgIGVuY29kZSxcbiAgICBkcmF3UVIsXG4gICAgcGVuYWx0eSxcbiAgICBQQVRURVJOUyxcbn07XG4vLyBUeXBlIHRlc3RzXG4vLyBjb25zdCBvMSA9IHFyKCd0ZXN0JywgJ2FzY2lpJyk7XG4vLyBjb25zdCBvMiA9IHFyKCd0ZXN0JywgJ3JhdycpO1xuLy8gY29uc3QgbzMgPSBxcigndGVzdCcsICdnaWYnKTtcbi8vIGNvbnN0IG80ID0gcXIoJ3Rlc3QnLCAnc3ZnJyk7XG4vLyBjb25zdCBvNSA9IHFyKCd0ZXN0JywgJ3Rlcm0nKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/qr/index.js\n");

/***/ })

};
;